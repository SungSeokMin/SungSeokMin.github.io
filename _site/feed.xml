<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://sungseokmin.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sungseokmin.github.io/" rel="alternate" type="text/html" /><updated>2021-01-31T18:25:45+09:00</updated><id>https://sungseokmin.github.io/feed.xml</id><title type="html">Happy Developer</title><subtitle>Happy Blog</subtitle><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><entry><title type="html">Express</title><link href="https://sungseokmin.github.io/backend/express/Express-backend/" rel="alternate" type="text/html" title="Express" /><published>2021-01-31T00:00:00+09:00</published><updated>2021-01-31T00:00:00+09:00</updated><id>https://sungseokmin.github.io/backend/express/Express-backend</id><content type="html" xml:base="https://sungseokmin.github.io/backend/express/Express-backend/">&lt;blockquote&gt;
  &lt;h2 id=&quot;express-&quot;&gt;Express ?&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://expressjs.com/ko/&quot;&gt;공식문서&lt;/a&gt; 참고&lt;/li&gt;
  &lt;li&gt;Node.js를 위한 빠르고 대중적인 프레임워크&lt;/li&gt;
  &lt;li&gt;Middleware를 사용할 수 있다는 큰 장점을 가지고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;설치-방법&quot;&gt;설치 방법&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install express
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;express를-이용한-server-구현&quot;&gt;express를 이용한 server 구현&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// express 모듈을 가져온다.
const express = require('express');
const app = express();

app.get('/', (request, response) =&amp;gt; {
  res.send('Hello World');
})

app.listen(3000, () =&amp;gt; {
  console.log('Express Start')
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;routing&quot;&gt;Routing&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;method(GET, POST, PUT, DELETE …)와 url에 따른 분기&lt;/li&gt;
  &lt;li&gt;즉, url 및 특정 HTTP 요청 메소드인 엔드포인트(ex… ‘/mypage’)에 대한 client 요청에 application이 응답하는 방법을 결정하는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const express = require('express');
const app = express();

// http://localhost:3000/ 경로로 이동할 경우 화면에 Hello가 출력된다.
app.get('/', (req, res) =&amp;gt; {
  res.status(200).send('Hello');
})

app.get('/mypage', (req,res) =&amp;gt; {
  res.status(200).send('MyPage');
})

app.post('경로', (req, res) =&amp;gt; {
  TODO :
})

app.delete('경로', (req, res) =&amp;gt; {
  TODO :
})

app.listen(3000, () =&amp;gt; {
  console.log('Express Start')
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;middleware&quot;&gt;Middleware&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;요청과 응답 중간에 껴서 어떠한 동작을 실행해주는 프로그램&lt;/li&gt;
  &lt;li&gt;대표적인 Middleware
    &lt;ul&gt;
      &lt;li&gt;morgan : request를 loggin 해주는 미들웨어&lt;/li&gt;
      &lt;li&gt;cors : 현재 도메인에서 다른 도메인으로 리소스 요청 할 경우 제한을 정해주는 미들웨어
        &lt;ul&gt;
          &lt;li&gt;Cross Origin Resource Sharing의 약자&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;express-session : 서버가 세션을 이용하게 해주고 쿠키에 세션 정보를 담을 수 있게 해주는 미들웨어&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;설치-방법-1&quot;&gt;설치 방법&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install morgan
npm install cors
npm install express-session
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;사용-방법&quot;&gt;사용 방법&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const express = require('express');
const app = express();
const morgan = require('morgan');
const cors = require('cors');
const session = require('express-session');

// 요청에 대한 본문을 해석해주는 미들웨어
app.use(express.json());

// post로 요청된 body를 쉽게 추출할 수 있는 미들웨어
app.use(express.urlencoded({extended: false}));

// morgan 미들웨어 사용
app.use(logger('dev'));

// cors 미들웨어 사용
app.use(
  cors({
    origin: 'https://localhost:3000',
    methods: ['GET', 'POST', 'UPDATE', 'OPTIONS'],
    credentials: true,
  })
);

// express-session 미들웨어 사용
app.use(session({
  secret: **필수항목** 비밀 키
  resave: false,
  saveUninitialized: false,
  cookie: {
    // 서버와 요청의 도메인이 일치하는 경우 쿠키 전송
    domain: 'localhost',

    // 서버의 요청의 세부경로가 일치하는 경우 쿠키 전송
    path: '/',

    // maxAge, expires =&amp;gt; 쿠키의 유효기간 설정
    maxAge: 24 * 6 * 60,

    // 스크립트의 쿠키 접근 가능 여부 설정
    httpOnly: true,

    // HTTPS에서만 쿠키 전송 여부 설정
    secure: true,

    // CORS 요청의 경우, 옵션 및 메소드에 따라 쿠키 전송 여부 설정
    sameSite: 'none'
  }
}))

app.listen(3000, () =&amp;gt; {
  console.log('Express Start');
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><category term="backend" /><category term="Express" /><summary type="html">Express ?</summary></entry><entry><title type="html">HTTP</title><link href="https://sungseokmin.github.io/backend/http/HTTP-backend/" rel="alternate" type="text/html" title="HTTP" /><published>2021-01-31T00:00:00+09:00</published><updated>2021-01-31T00:00:00+09:00</updated><id>https://sungseokmin.github.io/backend/http/HTTP-backend</id><content type="html" xml:base="https://sungseokmin.github.io/backend/http/HTTP-backend/">&lt;blockquote&gt;
  &lt;h2 id=&quot;http-&quot;&gt;HTTP ?&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;웹 상에서 client와 server 간에 요청/응답으로 데이터를 주고 받을 수 있는 프로토콜&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;작동방식&quot;&gt;작동방식&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;client -&amp;gt; (요청) -&amp;gt; server&lt;/li&gt;
  &lt;li&gt;Server -&amp;gt; (응답) -&amp;gt; client&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;특징&quot;&gt;특징&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;stateless(무상태성) : 이전 요청이나 다음 요청을 기억하지 않는다.
    &lt;ul&gt;
      &lt;li&gt;ex) client가 server에게 고기를 먹으러 가자고 요청을 보내자 server는 알겠다고 응답을 한다.&lt;/li&gt;
      &lt;li&gt;응답을 받은 client는 언제갈까 라고 server에게 요청을 보내지만 server는 무엇을? 이라는 응답을 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;connectionless(무연결성) : 한번의 요청에는 한번의 응답을 한다.
    &lt;ul&gt;
      &lt;li&gt;ex) client가 server에게 뭐해?, 바빠?, 어디갈까? 라는 요청을 한번에 보낼 수 없다는 뜻!!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메소드&quot;&gt;메소드&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;GET : 서버로부터 정보를 조회하기 위해 설계된 메소드
    &lt;ul&gt;
      &lt;li&gt;브라우저에서 웹페이지를 열거나 게시물을 읽는 등 조회하는 행위는 GET 요청&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;POST : 기존에 없던 리소스를 생성/변경하기 위해 설계된 메소드
    &lt;ul&gt;
      &lt;li&gt;기존에 없던 게시글을 작성하는 행위 등은 POST 요청&lt;/li&gt;
      &lt;li&gt;데이터가 Body로 전송된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PUT : 기존에 있던 리소스를 변경하기 위해 설계된 메소드
    &lt;ul&gt;
      &lt;li&gt;기존에 있던 게시글을 수정하는 행위 등은 PUT 요청&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DELETE : 리소스를 삭제하기 위해 설계된 메소드
    &lt;ul&gt;
      &lt;li&gt;게시글 삭제&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OPTIONS, TRACE, CONNECT …&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;get-post의-차이&quot;&gt;GET, POST의 차이&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;GET은 서버에게 동일한 요청을 여러 번 전송하더라도 동일한 응답이 돌아와야 하고
    &lt;ul&gt;
      &lt;li&gt;서버의 데이터나 상태를 변경시키지 않아야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;POST는 서버에게 동일한 요청을 여러 번 전송해도 응답이 항상 다를 수 있다.
    &lt;ul&gt;
      &lt;li&gt;서버의 데이터나 상태를 변경 시킬 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;http-header&quot;&gt;HTTP HEADER&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/header.png&quot; alt=&quot;Headers&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;response-status&quot;&gt;Response Status&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/request_status.png&quot; alt=&quot;응답코드&quot; /&gt;&lt;/p&gt;</content><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><category term="backend" /><category term="http" /><summary type="html">HTTP ?</summary></entry><entry><title type="html">Node.js</title><link href="https://sungseokmin.github.io/backend/node/Node-backend/" rel="alternate" type="text/html" title="Node.js" /><published>2021-01-31T00:00:00+09:00</published><updated>2021-01-31T00:00:00+09:00</updated><id>https://sungseokmin.github.io/backend/node/Node-backend</id><content type="html" xml:base="https://sungseokmin.github.io/backend/node/Node-backend/">&lt;blockquote&gt;
  &lt;h2 id=&quot;nodejs-&quot;&gt;Node.js ?&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;V8 JavaScript 엔진으로 빌드된 JavaScript 런타임&lt;/li&gt;
  &lt;li&gt;즉, 브라우저 외의 다른 환경에서도 사용할 수 있게 해주는 런타임&lt;/li&gt;
  &lt;li&gt;module 시스템을 구축하고 있다.&lt;/li&gt;
  &lt;li&gt;http server가 내장되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;설치-방법&quot;&gt;설치 방법&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;'https://nodejs.org'&quot;&gt;공식사이트&lt;/a&gt;를 통해 파일을 다운 받을 수 있다.&lt;/li&gt;
  &lt;li&gt;node가 설치되면 npm(Node Package Manager)가 같이 설치 된다.&lt;/li&gt;
  &lt;li&gt;설치가 되면 터미널을 켠 후 node -v와 npm -v를 입력해본다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;npm-&quot;&gt;npm ?&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;패키지를 모아놓은 저장소, 이미 만들어져 있는 패키지들을 사용할 수 있게 해주는 도구&lt;/li&gt;
  &lt;li&gt;패키지들을 체계적으로 관리하기 위해서 package.json을 생성한다. 패키지명, 패키지 버전을 기록한다.&lt;/li&gt;
  &lt;li&gt;package.json 생성방법
    &lt;ul&gt;
      &lt;li&gt;npm init&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;npm install [package Name]을 이용해 패키지들을 다운 받을 수 있다.
    &lt;ul&gt;
      &lt;li&gt;ex) npm install express&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;packagejson-&quot;&gt;package.json ?&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;패캐지들을 체계적으로 관리하기 위해서 필요한 파일&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dependencies-devdependencies&quot;&gt;dependencies, devDependencies&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;dependencies ?
    &lt;ul&gt;
      &lt;li&gt;프로젝트에 필요한 패키지들의 이름과 버전을 기록
        &lt;ul&gt;
          &lt;li&gt;ex) express, cors, sequelize, mysql2 …&lt;/li&gt;
          &lt;li&gt;설치) npm install express&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;devDependencies ?
    &lt;ul&gt;
      &lt;li&gt;프로젝트 개발에 필요한 패캐지들의 이름과 버전을 기록
        &lt;ul&gt;
          &lt;li&gt;ex) nodemon, eslint, prettier …&lt;/li&gt;
          &lt;li&gt;설치) npm install nodemon –save-dev&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;server-구현&quot;&gt;server 구현&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// http 모듈을 불러온다.
const http = require('http');
const url = require('url');

// http://localhost:3000 확인 가능
http.createServer((request, response) =&amp;gt; {

  // user가 요청한 url에서 path를 가져온다.
  const path = url.parse(request.url, true).pathname;

  // user가 요청한 method가 GET, POST, 그 외 일 경우
  if(request.method === 'GET') {
    // path가 /일 경우
    if(path === '/') {
      ...
    }
  } else if(request.method === 'POST') {
    ...
  } else {
    ...
  }

}).listen(3000);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><category term="backend" /><category term="node" /><summary type="html">Node.js ?</summary></entry><entry><title type="html">LSCS-연속된 부분 배열의 합의 최대값</title><link href="https://sungseokmin.github.io/algorithm/LSCS-algorithm/" rel="alternate" type="text/html" title="LSCS-연속된 부분 배열의 합의 최대값" /><published>2021-01-30T00:00:00+09:00</published><updated>2021-01-30T00:00:00+09:00</updated><id>https://sungseokmin.github.io/algorithm/LSCS-algorithm</id><content type="html" xml:base="https://sungseokmin.github.io/algorithm/LSCS-algorithm/">&lt;h2 id=&quot;lscs&quot;&gt;LSCS&lt;/h2&gt;

&lt;h3 id=&quot;문제설명&quot;&gt;문제설명&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;정수를 요소로 갖는 배열 &lt;br /&gt;
주어진 배열의 연속된 부분 배열의 합을 구한다.&lt;br /&gt;
이 중 가장 큰 값을 리턴해야 한다.&lt;br /&gt;
배열의 모든 요소가 음수인 경우도 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let output = LSCS([1, 2, 3]);
console.log(output); // --&amp;gt; 6

output = LSCS([1, 2, 3, -4]);
console.log(output); // --&amp;gt; 6

LSCS([1, 2, 3, -4, 5]);
console.log(output); // --&amp;gt; 7

LSCS([10, -11, 11]);
console.log(output); // --&amp;gt; 11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;수도코드&quot;&gt;수도코드&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;연속된 배열의 합을 저장할 변수 생성&lt;/li&gt;
  &lt;li&gt;연속된 부분 배열의 합을 저장할 변수 생성&lt;br /&gt;
2.1 Number.MIN_SAFE_INTEGER = -900719925474099&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;배열의 길이만큼 반복 … for loop&lt;/li&gt;
  &lt;li&gt;각각의 요소를 1번 변수에 저장 +=&lt;/li&gt;
  &lt;li&gt;만약 1번 변수의 합이 최대값 보다 클 경우 2번 변수에 저장&lt;/li&gt;
  &lt;li&gt;연속된 부분 배열의 합이 0보다 작을 경우 0으로 초기화를 해도 된다.&lt;/li&gt;
  &lt;li&gt;2번 변수를 return 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;풀이-코드&quot;&gt;풀이 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const LSCS = function(arr) {
  let result = 0;
  let max = Number.MIN_SAFE_INTEGER;

  for(let i = 0; i &amp;lt; arr.length; i++) {
    // 부분 합을 저장
    result += arr[i]

    // 최대값을 저장
    if(result &amp;gt; max) {
      max = result;
    }

    // 부분 합이 음수 인 경우 0으로 초기화
    if(result &amp;lt; 0) {
      result = 0;
    }
  }
  return max;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;간단한 문제라고 생각했지만 부분 합의 최대값 이라는 부분에서 어떻게 풀어가야할 지 생각이 많았다.&lt;/p&gt;</content><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><category term="algorithm" /><summary type="html">LSCS</summary></entry><entry><title type="html">최소시간으로 길찾기-완전탐색</title><link href="https://sungseokmin.github.io/algorithm/robotPath-algorithm/" rel="alternate" type="text/html" title="최소시간으로 길찾기-완전탐색" /><published>2021-01-30T00:00:00+09:00</published><updated>2021-01-30T00:00:00+09:00</updated><id>https://sungseokmin.github.io/algorithm/robotPath-algorithm</id><content type="html" xml:base="https://sungseokmin.github.io/algorithm/robotPath-algorithm/">&lt;h2 id=&quot;robot-path&quot;&gt;Robot Path&lt;/h2&gt;

&lt;h3 id=&quot;문제설명&quot;&gt;문제설명&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;2차원 배열(room), 현재 지점(src), 도착 지점(dst) &lt;br /&gt;
1은 장애물, 0은 이동 가능한 통로를 의미한다. &lt;br /&gt;
로봇은 지도 위를 일분에 한 칸씩 상하좌우로 이동 할 수 있다. &lt;br /&gt;
로봇의 위치와 목표 지점이 함께 주어질 경우
로봇이 목표 지점까지 도달하는 데 걸리는 최소 시간을 리턴&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let room = [
  [0, 0, 0, 0, 0, 0],
  [0, 1, 1, 0, 1, 0],
  [0, 1, 0, 0, 0, 0],
  [0, 0, 1, 1, 1, 0],
  [1, 0, 0, 0, 0, 0],
];
let src = [4, 2];
let dst = [2, 2];
let output = robotPath(room, src, dst);
console.log(output); // --&amp;gt; 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;수도코드&quot;&gt;수도코드&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;recursion 함수 생성 … (세로의 길이, 가로의 길이, 현재 지점, 최소시간=1)&lt;/li&gt;
  &lt;li&gt;배열의 범위가 벗어난 경우 return&lt;/li&gt;
  &lt;li&gt;room의 [row, col]이 0인 경우 와 최소시간 보다 큰 경우 &lt;br /&gt;
3.1 room의 [row, col]을 최소시간(step)으로 초기화 한다.&lt;/li&gt;
  &lt;li&gt;그것이 아니면 return &lt;br /&gt;
4.1 그 이유 ? 장애물이 이미 1이거나, 최소 시간으로 통과 가능한 경우니깐 !&lt;/li&gt;
  &lt;li&gt;상하좌우로 재귀한다.&lt;/li&gt;
  &lt;li&gt;완전탐색이 끝나면 도착지점의 row, col을 구조분해 하고&lt;/li&gt;
  &lt;li&gt;room의 row, col 자리의 값 = 최소시간에서 1을 빼준다. &lt;br /&gt;
7.1 그 이유? 방문하지 않기 위해 로봇의 위치를 1로 초기화 하면&lt;br /&gt;
7.2 바로 옆 통로는 1이 증가한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;풀이-코드&quot;&gt;풀이 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const robotPath = function (room, src, dst) {
  const recursion = (M, N, path, step) =&amp;gt; {
    // 현재 점을 저장
    const [row, col] = path;

    // 배열의 범위를 벗어난 경우
    if(row &amp;lt; 0 || row &amp;gt;= M || col &amp;lt; 0 || col &amp;gt;= N) {
      return;
    }

    // 이동할 수 있는 경우
    if(room[row][col] === 0 || room[row][col] &amp;gt; step) {
      room[row][col] = step;
    } else {
      return;
    }

    // 상
    recursion(M, N, [row+1, col], step + 1);
    // 하
    recursion(M, N, [row-1, col], step + 1);
    // 좌
    recursion(M, N, [row, col-1], step + 1);
    // 우
    recursion(M, N, [row, col+1], step + 1);
  }
  // 세로, 가로, 현재지점, 최소시간
  recursion(room.length, room[0].length, src, 1);

  const [row, col] = dst;
  return room[row][col] -1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;문제파악과 해결하는 부분에서 시간이 엄청 오래걸렸다.
DFS, BFS에 대한 개념을 더 익히는 것이 필요한 것 같다.&lt;/p&gt;</content><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><category term="algorithm" /><summary type="html">Robot Path</summary></entry></feed>