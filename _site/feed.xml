<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://sungseokmin.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sungseokmin.github.io/" rel="alternate" type="text/html" /><updated>2021-05-25T22:12:47+09:00</updated><id>https://sungseokmin.github.io/feed.xml</id><title type="html">Happy Developer</title><subtitle>Happy Blog</subtitle><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><entry><title type="html">Toy_회원가입 및 로그인</title><link href="https://sungseokmin.github.io/project/toy/toysiginsignup/" rel="alternate" type="text/html" title="Toy_회원가입 및 로그인" /><published>2021-05-13T00:00:00+09:00</published><updated>2021-05-13T00:00:00+09:00</updated><id>https://sungseokmin.github.io/project/toy/toysiginsignup</id><content type="html" xml:base="https://sungseokmin.github.io/project/toy/toysiginsignup/">&lt;blockquote&gt;
  &lt;h2 id=&quot;사용한-모듈&quot;&gt;사용한 모듈&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/72539723/118116692-8b5f4b80-b425-11eb-9453-3bcc598a4256.png&quot; alt=&quot;module&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;nodejs-및-expressjs-설치&quot;&gt;node.js 및 express.js 설치&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;node : Chrome V8 엔진으로 빌드된 JavaScript 런타임&lt;/li&gt;
  &lt;li&gt;nvm(node version manager) : 여러 개의 nodejs를 설치하고 사용할 버전을 쉽게 전활할 수 있도록 도와주는 역할&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;터미널-실행-후&quot;&gt;터미널 실행 후&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nvm 설치
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash

최신 버전 설치
nvm install node

특정 버전 설치
nvm install 12.18.3

노드 사용
nvm use 12.18.3

내 컴퓨터 안에 설치되어 있는 노드 버전 목록
nvm ls
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;express-설치-후-서버-오픈&quot;&gt;express 설치 후 서버 오픈&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;express : Node.js를 위한 빠르고 간편한 웹 프레임워크&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;express 설치&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;npm install express –save&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// index.js

const express = require('express');
const app = express();
const port = 5000;

app.get('/', (req, res) =&amp;gt; res.send('Hello World'));

app.listen(port, () =&amp;gt; console.log(`running on ${port}`))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;mongodb-연결&quot;&gt;MongoDB 연결&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;https://www.mongodb.com 접속 후 회원가입&lt;/li&gt;
  &lt;li&gt;Create a New Cluster&lt;/li&gt;
  &lt;li&gt;Cluster를 만들었다면 SANDBOX 왼쪽 부분에 CONNECT 클릭&lt;/li&gt;
  &lt;li&gt;UserName과 Password 입력 후 Create Database User&lt;br /&gt;❗️나중에 DB연결을 위해 name과 password 기억❗️&lt;/li&gt;
  &lt;li&gt;Connect your application 클릭 후 mongodb+srv로 시작하는 문자열 복사해두기&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;VSCode로 이동 후 mongoose 설치&lt;br /&gt;npm install moongose –save&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;mongoose 모듈을 불러온 후 connect 하기&lt;/li&gt;
  &lt;li&gt;연결이 잘 되었나 확인&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const mongoose = require('mongoose');

❗️5번에서 복사한 문자열 중 &amp;lt;password&amp;gt; 부분 삭제 후 4번에서 작성한 password 적어주기❗️

mongoose.connect('5번에서 복사한 문자열 붙여넣기', {
  useNewUrlParser: true,
  useUnifiedTopology: true,
  useCreateIndex: true,
  useFindAndModify: true,
}).then(() =&amp;gt; console.log('MongoDB Connected...'))
  .catch((err) =&amp;gt; console.log(err));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;연결-확인&quot;&gt;연결 확인&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// package.json

=&amp;gt; scripts 부분에 start 명시
&quot;scripts&quot;: {
    &quot;start&quot;: &quot;node index.js&quot;,
  },
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm run start

=&amp;gt; MongoDB Connected... 문구 확인
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;mongodb-model--schema&quot;&gt;MongoDB Model &amp;amp; Schema&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;최상위 루트에 models 디렉토리 생성 후 하위에 User.js 파일 생성&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// User.js

const mongoose = require('mongoose');

const userSchema = mongoose.Schema({
  name: {
    type: String,
    maxlength: 50, /* 문자열 최대 길이 */,
  },
  email: {
    type: String,
    trim: true /* email의 공백을 허용하지 않는다. */,
  },
  password: {
    type: String,
    minlength: 5, /* 문자열 최소 길이 */
  },
  lastname: {
    type: String,
    maxlength: 50,
  },
  role: {
    /* 일반유저, 관리자 등을 파악하기 위한 model */
    type: Number,
    default: 0,
  },
  image: String,
  token: {
    type: String,
  },
  tokenExp: {
    // token 유효기간
    type: Number,
  },
});

/* schema를 model로 감싼 후 exports */
const User = mongoose.model('User', userSchema);

module.exports = { User };

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;bodyparser&quot;&gt;BodyParser&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;BodyParser : Client의 request의 body 데이터를 분석해 주는 역할&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;❌ express 4.16버전 이후로는 bodyParser가 지원되지 않는다.❌&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;설치
npm install body-parser --save

4.16버전 이전

// application/x-www-form-urlencoded
app.use(bodyParser.urlecoded({extended: true}));

// application/json
app.use(bodyParser.json());

4.16버전 이후

// application/x-www-form-urlencoded
app.use(express.urlencoded({extended: true}));

// application/json
app.use(express.json());

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;회원가입-기능&quot;&gt;회원가입 기능&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;http method 중 post를 이용해서 Route처리&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// index.js

const { User } = require('./models/User');

app.post('/register', (req, res) =&amp;gt; {
  // User model을 가져온 후 인스턴스화
  const user = new User(req.body);

  user.save((err, userInfo) =&amp;gt; {
    /* 만약 user에 정보를 저장하는데 에러가 나면 success를 false로 응답하고 그렇지 않은 경우에는 true로 응답한다 */
    if(err) return res.json({success: false, err});
    return res.status(200).json({success: true});
  })
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;bcrypto를-이용한-비밀번호-암호화&quot;&gt;bcrypto를 이용한 비밀번호 암호화&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;💡 코드를 보기 앞서 신경써야 할 부분&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mongoose의 method 중 &amp;lt;pre(‘save’)&amp;gt; : DB에 저장하기 전 (.save()) 실행 되는 함수&lt;/li&gt;
  &lt;li&gt;this&lt;/li&gt;
  &lt;li&gt;saltRounds&lt;/li&gt;
  &lt;li&gt;next();&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// models/User.js

const bcrypt = require('bcrypt);
const saltRounds = 10; =&amp;gt; salt의 자릿수를 지정

userSchema.pre('save', function (next) {
  /* index.js파일에서 const user = new User(req.body); 를 통해 인스턴스화를 했기 때문에 this는 req.body의 정보로 들어온 사용자가 된다. */
  let user = this;

  // isModified는 mongoose의 method
  if (user.isModified('password')) {
    // 비밀번호 암호화 시키기
    bcrypt.genSalt(saltRounds, function (err, salt) {
      if (err) return next(err);

      bcrypt.hash(user.password, salt, function (err, hash) {
        if (err) return next(err);
        user.password = hash;
        next(); =&amp;gt; index.js의 save하는 함수로 이동시킨다.
      });
    });
  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;login-기능-구현&quot;&gt;Login 기능 구현&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;jsonwebtoken 설치
    &lt;ul&gt;
      &lt;li&gt;npm install jsonwebtoken –save&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cookie-parser 설치
    &lt;ul&gt;
      &lt;li&gt;npm install cookie-parser&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;순서&quot;&gt;순서&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;‘/login’ endpoint로 route 처리&lt;/li&gt;
  &lt;li&gt;client로 부터 넘어온 data 중 email이 DB에 있는지 없는지 확인&lt;/li&gt;
  &lt;li&gt;있다면 비밀번호가 일치하는 지 확인&lt;/li&gt;
  &lt;li&gt;2,3 조건이 만족한다면 Token 생성후 응답&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// index.js
const cookieParser = require('cookie-parser');
app.use(cookieParser());

app.post('/login', (req, res) =&amp;gt; {
  // 1. 요청된 이메일을 데이터베이스에서 있는지 찾는다.
  User.findOne({ email: req.body.email }, (err, user) =&amp;gt; {
    if (!user) {
      return res.json({
        loginSuccess: false,
        message: '제공된 이메일에 해당하는 유저가 없습니다.',
      });
    }
    // 2. 요청된 이메일이 데이터 베이스에 있다면 비밀번호가 맞는 비밀번호 인지 확인.
    user.comparePassword(req.body.password, (err, isMatch) =&amp;gt; {
      if (!isMatch) {
        return res.json({ loginSuccess: false, message: '비밀번호가 틀렸습니다.' });
      }
      // 3. 1,2번 조건이 만족 한다면 token 생성
      user.generateToken((err, user) =&amp;gt; {
        if(err) return res.status(400).send(err);

        res.cookie('x_auth', user.token).status(200).json({loginSuccess: true, userId: user._id})
      });
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// User.js
const jwt = require('jsonwebtoken');

=&amp;gt; comparePassword
userSchema.methods.comparePassword = function(plainPassword, callback) {
  bcrypt.compare(plainPassword, this.password, (err, isMatch) =&amp;gt; {
    if(err) return callback(err);
    return callback(null, isMatch); =&amp;gt; isMatch의 값은 boolean
  })
}

=&amp;gt; generateToken
userSchema.methods.generateToken = function (cb) {
  let user = this;

  // MongoDB에서 생성된 _id는 string이 아니므로 toHexString() 메소드를 사용해서 형변환을 해줘야한다.
  const token = jwt.sign(user._id.toHexString(), 'secretToken');

  user.token = token;

  user.save(function (err, user) {
    if (err) return cb(err);
    cb(null, user);
  });
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;auth-기능-구현&quot;&gt;Auth 기능 구현&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;순서-1&quot;&gt;순서&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;middleware 폴더 생성 후 하위 auth.js 파일 생성&lt;/li&gt;
  &lt;li&gt;findByToken을 statics method를 이용해 함수 작성&lt;/li&gt;
  &lt;li&gt;User 모델 require 후 auth 함수 작성&lt;/li&gt;
  &lt;li&gt;index.js에서 auth route 처리&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// auth.js

const { User } = require('../models/User');

let auth = (req, res, next) =&amp;gt; {
  // client cookie에서 토큰을 가져온다.
  let token = req.cookies.x_auth;

  // 토큰을 복호화 한 후 유저를 찾는다.
  User.findByToken(token, (err, user) =&amp;gt; {
    if (err) throw err;
    if (!user) return res.json({ isAuth: false, error: true });

    req.token = token;
    req.user = user;
    next();
  });
};

module.exports = { auth };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// User.js

userSchema.statics.findByToken = function (token, cb) {
  let user = this;

  // 토큰을 복호화 한다.
  jwt.verify(token, 'secretToken', function (err, decoded) {
    user.findOne({ _id: decoded, token: token }, function (err, user) {
      if (err) return cb(err);
      cb(null, user);
    });
  });
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// index.js

app.get('/api/users/auth', auth, (req, res) =&amp;gt; {
  res.status(200).json({
    _id: req.user._id,
    isAdmin: req.user.role === 0 ? false : true,
    isAuth: true,
    email: req.user.email,
    name: req.user.name,
    lastname: req.user.lastname,
    role: req.user.role,
    image: req.user.image,
  });
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;logout-기능-구현&quot;&gt;Logout 기능 구현&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;순서-2&quot;&gt;순서&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;DB에 저장한 token 값을 삭제하면 auth middleware가 동작을 안 하기 때문에 로그아웃이 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// index.js

app.get('/api/users/logout', auth, (req, res) =&amp;gt; {
  User.findOneAndUpdate({ _id: req.user._id }, { token: '' }, (err, user) =&amp;gt; {
    if (err) return res.json({ success: false, err });
    return res.status(200).send({ success: true });
  });
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/SungSeokMin/boiler-plate_signIn_signUp&quot;&gt;Git&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;출처 : 인프런(따라하며 배우는 노드, 리액트 시리즈) - John Ahn&lt;/p&gt;</content><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><category term="project" /><category term="Toy" /><summary type="html">사용한 모듈</summary></entry><entry><title type="html">JavaScript</title><link href="https://sungseokmin.github.io/interview/Interview-JavaScript/" rel="alternate" type="text/html" title="JavaScript" /><published>2021-05-10T00:00:00+09:00</published><updated>2021-05-10T00:00:00+09:00</updated><id>https://sungseokmin.github.io/interview/Interview-JavaScript</id><content type="html" xml:base="https://sungseokmin.github.io/interview/Interview-JavaScript/">&lt;blockquote&gt;
  &lt;h2 id=&quot;var-let-const-차이점&quot;&gt;var, let, const 차이점&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;var는 함수레벨이 하나의 유효범위를 가지고 let과 const는 블럭레벨이 하나의 유호범위를 가진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;scope&quot;&gt;scope&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;변수에 접근할 수 있는 유효범위&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;함수 스코프 (var)&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;함수 외부에서 함수 내부의 변수에 접근 불가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;블럭 스코프 (let, const)&lt;/p&gt;
        &lt;ul&gt;
          &lt;li&gt;블럭 외부에서 블럭 내부의 변수에 접근 불가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;closure&quot;&gt;Closure&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;내부 함수가 외부 함수의 지역변수에 접근 할 수 있는 것으로 변수를 private하게 사용하고 싶을 때 closure를 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;callback&quot;&gt;Callback&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;파라미터로 함수를 전달 받아, 함수의 내부에서 실행하는 함수
    &lt;ul&gt;
      &lt;li&gt;때가 되면 나중에 호출 한다는 것이 콜백함수의 기본 개념&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;this&quot;&gt;this&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;일반 함수는 호출 위치에 따라 this가 정의
    &lt;ul&gt;
      &lt;li&gt;일반 함수 실행&lt;/li&gt;
      &lt;li&gt;dot notaition (객체의 메소드 실행)&lt;/li&gt;
      &lt;li&gt;new 키워드&lt;/li&gt;
      &lt;li&gt;call, apply, bind 실행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;화살표 함수는 자신이 선언된 함수 범위에서 this가 정의&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;event-loop&quot;&gt;Event Loop&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Memory Heap
    &lt;ul&gt;
      &lt;li&gt;메모리 할당이 일어나는 곳&lt;/li&gt;
      &lt;li&gt;Heap ?
        &lt;ul&gt;
          &lt;li&gt;구조화되지 않은 메모리 영역&lt;/li&gt;
          &lt;li&gt;객체(변수, 함수)들이 담김&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Call Stack&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;실행될 코드의 한 줄 단위로 할당&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Web APIs&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;비동기 처리를 담당&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Callback Queue&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;비동기 처리가 끝난 후 실행되어야 할 콜백 함수가 차례로 할당&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Event Loop
    &lt;ul&gt;
      &lt;li&gt;Queue에 할당된 함수를 순서에 맞춰 Call Stack에 할당&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;비동기-처리-함수가-있는-경우&quot;&gt;비동기 처리 함수가 있는 경우&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;함수가 실행되면 Call Stack에 쌓이고 출력된다.&lt;/li&gt;
  &lt;li&gt;다음 함수가 비동기 처리 일 경우 Web APIs로 이동되고&lt;/li&gt;
  &lt;li&gt;비동기 처리가 끝나면 Callback Queue로 이동된다.&lt;/li&gt;
  &lt;li&gt;이때 Event Loop는 Call Stack이 비었는지 확인&lt;/li&gt;
  &lt;li&gt;비어있으면 Call Stack으로 이동 후 출력, 비어있지 않으면 Call Stack이 출력 될 때 까지 기다린다.&lt;/li&gt;
  &lt;li&gt;남아있던 Call Stack이 다 출력 될 경우 Callback Queue에서 Call Stack으로 이동된다.&lt;/li&gt;
  &lt;li&gt;Call Stack으로 이동된 비동기 처리 함수들이 출력된다.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><category term="interview" /><summary type="html">var, let, const 차이점</summary></entry><entry><title type="html">Front-End</title><link href="https://sungseokmin.github.io/interview/Interview-FrontEnd/" rel="alternate" type="text/html" title="Front-End" /><published>2021-05-06T00:00:00+09:00</published><updated>2021-05-06T00:00:00+09:00</updated><id>https://sungseokmin.github.io/interview/Interview-FrontEnd</id><content type="html" xml:base="https://sungseokmin.github.io/interview/Interview-FrontEnd/">&lt;blockquote&gt;
  &lt;h2 id=&quot;csrclient-side-rendering--ssrserver-side-rendering&quot;&gt;CSR(Client Side Rendering) &amp;amp; SSR(Server Side Rendering)&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CSR ?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;브라우저가 서버에 HTML, JS파일을 요청한 후 로드되면 사용자의 상호작용에 따라 JS를 이용해서 동적으로 페이지를 렌더링 시키는 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SSR ?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;브라우저가 페이지를 요청할 때마다 HTML, CSS, JS 파일 및 데이터를 받아와서 페이지를 렌더링 시키는 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;장점과-단점&quot;&gt;장점과 단점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;CSR의 경우는 처음 로딩하는 시간이 오래 걸리고, 검색엔진 초기화(SEO)의 문제가 있지만, 각 페이지 요청 시 빠르게 렌더링 되기 때문에 UX(사용자 경혐)이 좋다.&lt;/li&gt;
  &lt;li&gt;SSR의 경우는 처음 로딩하는 시간이 짧고, 검색엔진 초기화(SEO)가 가능하지만, 각 페이지 요청 시 새로고침 되기 때문에 UX(사용자 경험)가 좋지 않다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;rest-api&quot;&gt;REST API&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;REST
    &lt;ul&gt;
      &lt;li&gt;자원의 표현을 가지고 상태를 전달한다.&lt;/li&gt;
      &lt;li&gt;자원을 URI에 명시를 하고, 상태를 Http method로 명시한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;API
    &lt;ul&gt;
      &lt;li&gt;기존에 있는 응용 프로그램을 통해서 데이터를 제공받거나 기능을 사용하고자 할 때 사용하는 인터페이스 및 규격&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;REST API
    &lt;ul&gt;
      &lt;li&gt;REST 원칙을 적용하여 서비스 API를 설계한 것을 말한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;rest-원칙&quot;&gt;REST 원칙&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;인터페이스 일관성 ⭐️&lt;/li&gt;
  &lt;li&gt;클라이언트/서버 : request, response가 있어야 한다.&lt;/li&gt;
  &lt;li&gt;무상태 : 이전 요청이 다음 요청의 처리에 연관되면 안된다.&lt;/li&gt;
  &lt;li&gt;캐시 처리 가능&lt;/li&gt;
  &lt;li&gt;계층화&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;브라우저-렌더링-과정&quot;&gt;브라우저 렌더링 과정&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;HTML 파싱 후, DOM 트리 구축&lt;/li&gt;
  &lt;li&gt;CSS 파싱 후, CSSSOM 트리 구축&lt;/li&gt;
  &lt;li&gt;JavaScript 실행 (❗️ script태그가 HTML 중간에 있다면 HTML 파싱이 중단된다.)&lt;/li&gt;
  &lt;li&gt;DOM과 CSSOM을 조합하여 렌더트리 구축&lt;/li&gt;
  &lt;li&gt;렌더트리의 각 노드가 가지는 정확한 위치와 크기를 계산해서 화면에 그린다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;dom&quot;&gt;Dom&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;문서 객체 모델, HTML,XML 문서의 프로그래밍 interface&lt;/li&gt;
  &lt;li&gt;프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법을 제공하여 문서 구조, 스타일, 내용 등을 변경할 수 있게 돕는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;virtual-dom&quot;&gt;Virtual Dom&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;변화가 일어나면 실제로 브라우저의 DOM에 새로운 것을 넣는 게 아니라
JavaScript로 이루어진 가상의 DOM에 한번 렌더링 하고 기존의 DOM과 비교를 한 후 변화가 필요한 곳에만 업데이트를 해주는 역할&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;http--https&quot;&gt;HTTP &amp;amp; HTTPS&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜
        &lt;ul&gt;
          &lt;li&gt;80번 포트를 사용하며, 인터넷에서 하이퍼텍스트를 교환하기 위한 통신 규약&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTPS&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;HTTP에 데이터 암호화가 추가된 프로토콜
        &lt;ul&gt;
          &lt;li&gt;433번 포트를 사용하며, 네트워크 상에서 중간에 제3자가 정보를볼 수 없도록 공개키 암호화를 지원&lt;/li&gt;
          &lt;li&gt;검색엔진 최적화(SEO)에 있어서 혜택을 받음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;cors&quot;&gt;CORS&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;xss&quot;&gt;XSS&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;악의적인 사용자가 스크립트를 넣어 쿠키, 세션등의 정보를 탈취하는 공격 기법&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;대책&quot;&gt;대책&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;쿠키에 중요한 정보를 담지 않고 서버에 중요 정보를 저장&lt;/li&gt;
  &lt;li&gt;HttpOnly 옵션을 통해 cookie에 접근을 방지&lt;/li&gt;
  &lt;li&gt;문자열 치환&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;csrf&quot;&gt;CSRF&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 하는 공격 기법&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;대책-1&quot;&gt;대책&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Referer 검증&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;서버에서 request의 referer 확인하여 domain이 일치하는지 검증&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;데이터-바인딩-단방향-양방향&quot;&gt;데이터 바인딩 (단방향, 양방향)&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;데이터 바인딩&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;화면에 보이는 데이터와 브라우저 메모리에 있는 데이터를 일치시키는 기법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;단방향 데이터 바인딩&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;데이터에 변화가 생기면 특정함수를 실행시킨 후 다시 렌더링 되어서 DOM을 갱신&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;양방향 데이터 바인딩&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;웹페이지의 변수 입력 부분을 수정하게 되면 JavaScript 변수의 값도 변경되어 실시간으로 DOM을 갱신&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;mvc-패턴&quot;&gt;MVC 패턴&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Model : Controller에게 받은 요청에 따라 데이터를 관리하고 해당 데이터를 다시 Controller에게 전송한다.&lt;/li&gt;
  &lt;li&gt;View : 사용자한테 보여지는 부분으로 Controller로부터 전달받은 데이터를 Client로 전송해 결과를 나타낸다.&lt;/li&gt;
  &lt;li&gt;Controller : Model로 데이터 요청을 보낸 후 전달받은 데이터를 View에 전송한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;flux-패턴&quot;&gt;Flux 패턴&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;시스템에서 어떠한 Action을 받았을 때, Dispatcher가 받은 Action들을 통제하여 Store에 있는 데이터를 업데이트한 후 변경된 데이터가 있으면 View에 리렌더링 한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><category term="interview" /><summary type="html">CSR(Client Side Rendering) &amp;amp; SSR(Server Side Rendering)</summary></entry><entry><title type="html">SCSS</title><link href="https://sungseokmin.github.io/frontend/html/SCSS/" rel="alternate" type="text/html" title="SCSS" /><published>2021-04-25T00:00:00+09:00</published><updated>2021-04-25T00:00:00+09:00</updated><id>https://sungseokmin.github.io/frontend/html/SCSS</id><content type="html" xml:base="https://sungseokmin.github.io/frontend/html/SCSS/">&lt;blockquote&gt;
  &lt;h2 id=&quot;scss&quot;&gt;SCSS&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;CSS 전처리기(CSS Preprocessor)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;왜 사용하나요 ??
    &lt;ul&gt;
      &lt;li&gt;CSS의 불편함을 SCSS와 같은 확장 기능을 이용해 줄일 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;간단한-맛-보기&quot;&gt;&lt;span style=&quot;color: royalblue&quot;&gt;간단한 맛 보기&lt;/span&gt;&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;===== HTML =====
&amp;lt;div class=&quot;container&quot;&amp;gt;
  &amp;lt;div class=&quot;aria&quot;&amp;gt;
    &amp;lt;h1&amp;gt;안녕하세요&amp;lt;/h1&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

===== CSS =====
.container {
  width: 100%;
  height: 100%
}

.container aria {
  width: 50%;
  height: 100%;
  background-color: black;
}

.container aria h1 {
  color: red;
}

===== SCSS =====
.container {
  .aria {
    background-color: black;
    h1 {
      color: $color;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;scss-주석의-2가지-방법&quot;&gt;SCSS 주석의 2가지 방법&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;기존의 CSS에서 사용한 방법 =&amp;gt; /* */&lt;/li&gt;
  &lt;li&gt;JS의 주석 방법 =&amp;gt; //&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;차이점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;컴파일 후 주석의 내용이 남아있느냐 남아있지 않느냐 차이!!
    &lt;ul&gt;
      &lt;li&gt;1번의 경우 주석의 내용이 남아있지만, 2번의 경우 주석의 내용이 남아있지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.container {
  .aria {
    width: 100%;
    /* height: 100%; */
    // background-color: blcak;
  }
}

===== 컴파일 후 =====
.container {
  .aria {
    width: 100%;
    /* height: 100%; */
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;상위-선택자-참조---&quot;&gt;상위 선택자 참조 ( &amp;amp; )&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;중첩 안에서 &amp;amp; 키워드는 부모 선택자를 참조하여 치환한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;===== SCSS =====
.btn {
  position: absolute;
  &amp;amp;.active {
    color: red;
  }
}

===== 컴파일 후 =====
.btn {
  position: absolute;
}

.btn.active {
  color: red;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;===== SCSS =====
.fs {
  %-small {font-size: 12px}
  %-medium {font-size: 14px}
  %-large {font-size: 16px}
}

===== 컴파일 후 =====
.fs-small{ font-size: 12px }
.fs-medium{ font-size: 14px }
.fs-large{ font-size: 16px }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;중첩된-속성&quot;&gt;중첩된 속성&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;각 속성의 하위 속성들을 중첩해서 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;❗️ 각 속성의 뒤에 : (콜론) 표시와 {} 영역 밖에 ; (세미콜론) 표시를 해줘야 한다. ❗️&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
===== SCSS =====
.box {
  font: ← ⭐️ {
    weight: bold;
    size: 14px;
  }; ← ⭐️
  maring: {
    left: 50px;
    right: 50px;
  }
  padding: {
    top: 20px;
    bottom: 20px;
  }
}

===== 컴파일 후 =====
.box {
  font-weight: bold;
  font-size: 14px;
  margin-left: 50px;
  margin-right: 50px;
  padding-top: 50px;
  padding-bottom: 50px;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;변수variables&quot;&gt;변수(Variables)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;JavaScript의 변수선언(let)과 같은 성향을 지닌다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$size: 100px; ← 전역으로 사용 가능

.container {
  position: relative;
  top : $size ← 위에서 전역적으로 선언한 변수 $size의 값 (100px)을 사용
  .item {
    width: $size;
    height: $size;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;⭐️ 유효범위 ⭐️&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$size: 100px; ← 전역으로 사용 가능

.container {
  $size: 50px;
  position: relative;
  top : $size
        ↑ 위에서 전역적으로 선언한 변수 $size의 값이 아닌 .container 안에서 재할당한 값 (50px)을 사용
  .item {
    $size: 500px;
    width: $size; ← .item 영역 안에서 재할당한 값 (500px)을 사용
    height: $size;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;scss-산술-연산&quot;&gt;SCSS 산술 연산&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;+&lt;/li&gt;
  &lt;li&gt;-&lt;/li&gt;
  &lt;li&gt;*&lt;/li&gt;
  &lt;li&gt;/ ❗ CSS의 단축속성 때문에 나머지 연산자가 적용이 안 될 수 있다.&lt;/li&gt;
  &lt;li&gt;%&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;===== SCSS =====
.box {
  width: 100px + 20px;
  height: 100px - 20px
  font-size: 10px * 2;
  margin: 20px / 2;
  padding: 20px % 7;
}

===== 컴파일 후 =====
.box {
  width: 120px;
  height: 80px;
  font-size: 20Px;
  margin: 20px/2; ❗ 적용이 안 된다.
  padding: 6px ;
}

❓ 그렇다면 어떻게 해야할까 ??
1. () 소괄호로 묶어준다.
2. 변수를 활용한다.

.box {
  $size: 100px;
  1. margin: (20px / 2);  =&amp;gt; margin: 10px;
  2. margin: $size / 2; =&amp;gt; margin: 50px;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;⭐️ 다른 단위의 산술연산을 하고 싶은 경우 ⭐️&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box {
  width: 100% - 20px; =&amp;gt; error
}
❓ 그렇다면 어떻게 해야할까 ??
1. CSS의 calc() 함수를 사용한다.

.box {
  width: calc(100% - 20px); =&amp;gt; good
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;mixin&quot;&gt;mixin&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;@mixin, @include 키워드를 통해서 코드를 재활용 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ex-flex를-이용한-가운데-정렬을-많이-해아한다-&quot;&gt;&lt;span style=&quot;color: royalblue&quot;&gt;Ex) flex를 이용한 가운데 정렬을 많이 해아한다 !!&lt;/span&gt;&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@mixin flexCenter {
  display: flex;
  justify-content: center;
  align-items: center;
}

===== SCSS =====
.container {
  @include flexCenter;
  .item {
    @include flexCenter;
  }
}

===== 컴파일 후 =====
.container {
  display: flex;
  justify-content: center;
  align-items: center;
}

.container .item {
  display: flex;
  justify-content: center;
  align-items: center;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;ex-mixin을-능동적으로-사용하려면-&quot;&gt;&lt;span style=&quot;color: royalblue&quot;&gt;Ex) @mixin을 능동적으로 사용하려면 ??&lt;/span&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;How ?
    &lt;ul&gt;
      &lt;li&gt;@mixin 키워드를 이용해 만든 변수에 매겨변수를 지정한다.&lt;/li&gt;
      &lt;li&gt;지정된 매개변수에 값이 없을 경우에는 default 값을 설정 할 수 있다. =&amp;gt; :(콜론)을 이용&lt;/li&gt;
      &lt;li&gt;width와 height는 default 값을 사용하고 싶고 background-color만 바꾸고 싶다면 ??
        &lt;ul&gt;
          &lt;li&gt;키워드 인수(접적으로 매개변수의 값을 지정)를 이용해 특정 값만 수정할 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;==== SCSS =====
                ↓ default 값을 설정할 수 있다.
@mixin box($size: 80px, $color: red) {
  width: $size;
  height: $size;
  background-color: $color;
}

.container {
  @include box(200px, tomato); ← @mixin의 매개변수($size, $color)의 값으로 '200px, tomato'가 사용 된다.
  .item {
                 ↓ 키워드 인수 =&amp;gt; $size의 값을 지정하지 않았으므로 default 값인 80px이 사용되고 $color의 값은 green이 사용 된다.
    @include box($color: green);
  }
}

==== 컴파일 후 =====
.container {
  width: 200px;
  height: 200px;
  background-color: tomato;
}

.container .item {
  width: 80px; ← @mixin의 매개변수($size)의 default 값이 할당 되었다.
  height: 80px;
  background-color: green; ← 키워드 인수($color)를 사용하여 바꾼 green의 값이 할당 되었다.
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;반복문&quot;&gt;반복문&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;문법 : @for $i from 1 through 3 {}
    &lt;ul&gt;
      &lt;li&gt;$i 변수에 1부터 10까지 반복을 하고 값을 저장한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;문자열 보간 :
여러 줄 문자열에 대해 연결 또는 이스케이프 문자를 사용하지 않고 변수, 함수 호출 및 산술 표현식을 문자열에 직접 삽입 할 수있는 기능입니다.

===== SCSS =====
@for $i from 1 through 3 {
  .box:nth-child(#{$i}) { ← 자바스크립트에서는 ${}의 방법으로 값을 보간 했다면 SCSS에서는 #{}의 방법으로 값을 보간한다.
    width: 100px * $i;
  };
}

==== 컴파일 후 =====
.box:nth-child(1) { width: 100px; }
.box:nth-child(2) { width: 200px; }
.box:nth-child(3) { width: 300px; }
.box:nth-child(4) { width: 400px; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;함수function&quot;&gt;함수(function)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;값을 리턴하는 함수(javascript의 함수와 동일)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;===== SCSS =====
@function ratio($size, $ratio) {
  @return $size * @ration;
}

.box {
  $width: 100px;
  width: $width;
  height: ratio(width, 1/2);
}

===== 컴파일 후 =====
.box {
  width: 100px;
  height: 50px;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;색상-내장-함수&quot;&gt;색상 내장 함수&lt;/h3&gt;

&lt;p&gt;mix(색상, 색상) : 색상을 섞는다.
lighten(색상, %) : 색상을 밝게 한다.
darken(색상, %) : 색상을 어둪게 한다.
saturate(색상, %) : 채도를 높인다.
desaturate(색상, %) : 채도를 낮춘다.
invert(색상) : 색상을 반전시킨다.
rgba(색상, 투명도)&lt;/p&gt;</content><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><category term="frontend" /><category term="HTML" /><summary type="html">SCSS</summary></entry><entry><title type="html">CSS</title><link href="https://sungseokmin.github.io/frontend/html/CSS/" rel="alternate" type="text/html" title="CSS" /><published>2021-03-09T00:00:00+09:00</published><updated>2021-03-09T00:00:00+09:00</updated><id>https://sungseokmin.github.io/frontend/html/CSS</id><content type="html" xml:base="https://sungseokmin.github.io/frontend/html/CSS/">&lt;blockquote&gt;
  &lt;h2 id=&quot;css-우선순위&quot;&gt;CSS 우선순위&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;!important(무한) &amp;gt; inline 선언(1000점) &amp;gt; ID선택자(100점) &amp;gt; Class선택자(10점) &amp;gt; 태그 선택자(1점) &amp;gt; 전체 선택자(0점)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;css-선택자&quot;&gt;CSS 선택자&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;기본&quot;&gt;기본&lt;/h3&gt;

&lt;p&gt;전체 선택자 : * &lt;br /&gt;
태그 선택자 : div, span, li … &lt;br /&gt;
클래스 선택자 : .className &lt;br /&gt;
아이디 선택자 : #idName &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;복합&quot;&gt;복합&lt;/h3&gt;

&lt;p&gt;일치 선택자 : 두 개의 선택자를 동시에 만족하는 요소&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;css =&amp;gt; span.orange (span 태그 중 class가 orange인 요소)
&amp;lt;span class=&quot;orange&quot;&amp;gt;오렌지&amp;lt;/span&amp;gt; ⭐️
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;복합 선택자 : 특정 선택자의 자식 요소를 선택&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;✔️ ‘&amp;gt;’가 선택자의 기호 ✔️&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;css =&amp;gt; ul &amp;gt; .orange (ul 태그의 자식요소 중 class가 orange인 요소)
&amp;lt;ul&amp;gt;
  &amp;lt;li class=&quot;orange&quot;&amp;gt;&amp;lt;/li&amp;gt; ⭐️
  &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하위 선택자 : 특정 선택자의 하위 요소&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;✔️ ‘띄어쓰기’가 선택자의 기호 ✔️&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;css =&amp;gt; div .orange (div 태그의 하위 요소 중 class가 orange인 요소)
&amp;lt;div&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li class=&quot;orange&quot;&amp;gt; ⭐️
  &amp;lt;/ul&amp;gt;
  &amp;lt;span class=&quot;orange&quot;&amp;gt; ⭐️
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;인접 형제 선택자 : 특정 선택자의 다음 형제 요소 하나를 선택&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;✔️ ‘+’가 선택자의 기호 ✔️&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;css =&amp;gt; .orange + li
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;사과&amp;lt;/li&amp;gt;
  &amp;lt;li calss=&quot;orange&quot;&amp;gt;오렌지&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;바나나&amp;lt;/li&amp;gt; ⭐️
  &amp;lt;li&amp;gt;키위&amp;lt;/li&amp;gt;
&amp;lt;ui&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일반 형제 선택자 : 특정 선택자의 다음 형제 요소 모두를 선택&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;✔️ ‘~’가 선택자의 기호 ✔️&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;사과&amp;lt;/li&amp;gt;
  &amp;lt;li calss=&quot;orange&quot;&amp;gt;오렌지&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;바나나&amp;lt;/li&amp;gt; ⭐️
  &amp;lt;li&amp;gt;키위&amp;lt;/li&amp;gt; ⭐️
&amp;lt;ui&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;가상-클래스&quot;&gt;가상 클래스&lt;/h3&gt;

&lt;p&gt;:hover : 마우스 커서가 올라가 있는 동안 선택&lt;/p&gt;

&lt;p&gt;:active : 마우스를 클릭하고 있는 동안 선택&lt;/p&gt;

&lt;p&gt;:focus : 해당 요소가 포커스 되면 선택&lt;/p&gt;

&lt;p&gt;:first-child : 선택자의 형제 요소 중 첫째 선택&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;css =&amp;gt; .fruits span:first-child
&amp;lt;div coass=&quot;fruits&quot;&amp;gt;
  &amp;lt;span&amp;gt;사과&amp;lt;/span&amp;gt; ⭐️
  &amp;lt;span&amp;gt;오렌지&amp;lt;/span&amp;gt;
  &amp;lt;p&amp;gt;바나나&amp;lt;/p&amp;gt;
  &amp;lt;span&amp;gt;키위&amp;lt;/span&amp;gt;
&amp;lt;div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;:last-child : 선택자의 형제 요소 중 막내 선택&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;css =&amp;gt; .fruits span:last-child
&amp;lt;div coass=&quot;fruits&quot;&amp;gt;
  &amp;lt;span&amp;gt;사과&amp;lt;/span&amp;gt;
  &amp;lt;span&amp;gt;오렌지&amp;lt;/span&amp;gt; ⭐️
  &amp;lt;p&amp;gt;바나나&amp;lt;/p&amp;gt;
  &amp;lt;span&amp;gt;키위&amp;lt;/span&amp;gt;
&amp;lt;div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;:nth-child(n) : 선택자의 형제 요소 중 (n)번째 선택&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;css =&amp;gt; .fruits *:nth-child(4) ❗️2n과 같이 2의 배수를 선택할 수도 있고 2n+1과 같이 홀수 선택 가능
&amp;lt;div coass=&quot;fruits&quot;&amp;gt;
  &amp;lt;span&amp;gt;사과&amp;lt;/span&amp;gt;
  &amp;lt;span&amp;gt;오렌지&amp;lt;/span&amp;gt;
  &amp;lt;p&amp;gt;바나나&amp;lt;/p&amp;gt;
  &amp;lt;span&amp;gt;키위&amp;lt;/span&amp;gt; ⭐️
&amp;lt;div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;:not(?) : 선택자가 아닌 요소 선택&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;css =&amp;gt; .fruits *:not(span)
&amp;lt;div coass=&quot;fruits&quot;&amp;gt;
  &amp;lt;span&amp;gt;사과&amp;lt;/span&amp;gt;
  &amp;lt;span&amp;gt;오렌지&amp;lt;/span&amp;gt;
  &amp;lt;p&amp;gt;바나나&amp;lt;/p&amp;gt; ⭐️
  &amp;lt;span&amp;gt;키위&amp;lt;/span&amp;gt;
&amp;lt;div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;가상-요소&quot;&gt;가상 요소&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;before, after는 inline 속성&lt;/li&gt;
  &lt;li&gt;그 말은 즉!! 가로와 세로의 길이를 조정할 수 없다.
    &lt;ul&gt;
      &lt;li&gt;조정하려면 display: bolck 설정!!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;::before : 선택자 요소의 내부 앞에 내용(content)을 삽입&lt;/p&gt;

&lt;p&gt;::after : 선택자 요소의 내부 뒤에 내용(content)을 삽입&lt;/p&gt;

&lt;h3 id=&quot;속성&quot;&gt;속성&lt;/h3&gt;

&lt;p&gt;속성 선택자 : 속성을 포함한 요소 선택&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[ATTR]&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;css =&amp;gt; [type]
&amp;lt;input type=&quot;text&quot; value=&quot;사과&quot; /&amp;gt; ⭐️
&amp;lt;input type=&quot;text&quot; value=&quot;사과&quot; /&amp;gt; ⭐️
&amp;lt;input type=&quot;text&quot; value=&quot;사과&quot; /&amp;gt; ⭐️
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;[ATTR=”VALUE”]&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;css =&amp;gt; [type=&quot;password&quot;]
&amp;lt;input type=&quot;text&quot; value=&quot;사과&quot; /&amp;gt;
&amp;lt;input type=&quot;password&quot; value=&quot;사과&quot; /&amp;gt; ⭐️
&amp;lt;input type=&quot;text&quot; value=&quot;사과&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;css-단위&quot;&gt;CSS 단위&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;px : 픽셀&lt;br /&gt;
% : 상대적 백분율&lt;br /&gt;
em : 요소의 글꼴 크기&lt;br /&gt;
rem : 루트 요소(html)의 글꼴 크기&lt;br /&gt;
vw : 뷰포트 가로 너비의 백분율&lt;br /&gt;
vh : 뷰포트 세로 너비의 백분율&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;css-속성&quot;&gt;CSS 속성&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;너비width--높이height&quot;&gt;너비(width) &amp;amp; 높이(height)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;기본 값(auto) : 브라우저가 자동으로 너비를 계산&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;개별 속성&lt;br /&gt;
max-width, min-width
max-height, max-height&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;외부여백margin&quot;&gt;외부여백(margin)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;기본 값 : 0&lt;/li&gt;
  &lt;li&gt;단위 : px, em, wv 등 단위로 지정&lt;/li&gt;
  &lt;li&gt;auto : 가운데 정렬&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;네 가지 표기 방법&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. margin : 10px; =&amp;gt; 상,하,좌,우
2. margin : 10px 20px; =&amp;gt; (상,하):10, (좌,우):20
3. margin : 10px 20px 30px =&amp;gt; 상:10, (좌,우):20, 하:30
4. margin : 10px 20px 30px 40px; =&amp;gt; 상:10, 우:20, 하:30, 좌:40
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;개별 속성&lt;br /&gt;
margin-top, margin-bottom, margin-left, margin-right&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;내부여백padding&quot;&gt;내부여백(padding)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;기본 값 : 0&lt;/li&gt;
  &lt;li&gt;단위 : px, em, vw등 단위로 지정&lt;/li&gt;
  &lt;li&gt;% : 부모 요소의 가로 너비에 대한 비율로 지정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;네 가지 표기 방법&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. padding : 10px; =&amp;gt; 상,하,좌,우
2. padding : 10px 20px; =&amp;gt; (상,하):10, (좌,우):20
3. padding : 10px 20px 30px =&amp;gt; 상:10, (좌,우):20, 하:30
4. padding : 10px 20px 30px 40px; =&amp;gt; 상:10, 우:20, 하:30, 좌:40
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;개별 속성&lt;br /&gt;
padding-top, padding-bottom, padding-left, padding-right&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;테두리border&quot;&gt;테두리(border)&lt;/h4&gt;

&lt;p&gt;border : 선-두께 선-종류 선-색상&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본 값 : medium none black&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;border : 1px solid red;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;개별 속성&lt;br /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;border-width : margin, padding의 네 가지 표기 방법과 동일&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;border-style : margin, padding의 네 가지 표기 방법과 동일&lt;br /&gt;
        &lt;ul&gt;
          &lt;li&gt;solid, dashed(파선), dotted(점선) 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;border-color : margin, padding의 네 가지 표기 방법과 동일&lt;br /&gt;
        &lt;ul&gt;
          &lt;li&gt;색상, transparent(투명)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;border-radius : px, em, % 등 단위로 지정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;색상 표현&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;색상 이름 : 브라우저에서 제공하는 색상 이름 &lt;br /&gt;
ex) red, royalblue, orange …&lt;/li&gt;
      &lt;li&gt;Hex 색상코드 : 16진수 색상 ex) #000, #FFFFFF&lt;/li&gt;
      &lt;li&gt;RGB : 빛의 삼원색 ex) rgb(255, 255, 255)&lt;/li&gt;
      &lt;li&gt;RGBA : 빛의 삼원색 + 투명도 ex)rgba(0, 0, 0, 0.5)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;box-sizing&quot;&gt;box-sizing&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;기본 값 : content-box(요소의 내용으로 크기 계산)&lt;/li&gt;
  &lt;li&gt;border-box : 요소의 내용 + padding + border로 크기 계산
    &lt;ul&gt;
      &lt;li&gt;지정한 가로, 세로크기를 그대로 유지하기 위해서 사용하는 속성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;overflow&quot;&gt;overflow&lt;/h4&gt;

&lt;p&gt;요소의 크기 이상으로 내용이 넘쳤을 때, 보여짐을 제어하는 속성&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;기본 값(visible) : 넘친 내용을 그대로 보여줌&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;개별 속성&lt;br /&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;hidden : 넘친 내용을 잘라냄&lt;/li&gt;
      &lt;li&gt;auto : 넘친 내용이 있는 경우에만 잘라내고 스크롤바 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;display&quot;&gt;display&lt;/h4&gt;

&lt;p&gt;요소의 화면 출력(보여짐) 특성&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;개별 속성&lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;block : 상자(레이아웃) 요소&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;inline : 글자 요소&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;inline-block : 글자 + 상자 요소&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;flex : 플렉스 박스 (1차원 레이아웃)&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;grid : 그리도 (2차원 레이아웃)&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;none : 보여짐 특성 없음, 화면에서 사라짐&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;투명도opacity&quot;&gt;투명도(opacity)&lt;/h4&gt;

&lt;p&gt;0부터 1 사이의 소수점 숫자&lt;/p&gt;

&lt;h4 id=&quot;글꼴font&quot;&gt;글꼴(font)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;font-style : 글자의 기울기
    &lt;ul&gt;
      &lt;li&gt;기본 값 : normal&lt;/li&gt;
      &lt;li&gt;이텔릭체 : italic&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;font-weight : 글자의 두께
    &lt;ul&gt;
      &lt;li&gt;기본 값 : normal(400)&lt;/li&gt;
      &lt;li&gt;두껍게 : bold, 700&lt;/li&gt;
      &lt;li&gt;범위 : 100단위의 숫자 9개 (100 ~ 900)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;font-size : 글자의 크기
    &lt;ul&gt;
      &lt;li&gt;기본 값 : normal (16px)&lt;/li&gt;
      &lt;li&gt;단위 : px, em, rem 등 단위로 지정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;line-height : 한 줄의 높이, 행간과 유사
    &lt;ul&gt;
      &lt;li&gt;기본 값 : normal&lt;/li&gt;
      &lt;li&gt;숫자 : 요소의 글꼴 크기의 배수로 지정
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;line-height : 1.4  ex) 글꼴 크기가 16px이라고 가정하면 높이는 16 * 1.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;문자text&quot;&gt;문자(text)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;color : 색깔
    &lt;ul&gt;
      &lt;li&gt;기본 값 : rgb(0,0,0) =&amp;gt; 검정색&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;text-align : 문자의 정렬방식
    &lt;ul&gt;
      &lt;li&gt;left(기본값), right, center&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;text-decoration : 문자의 장식(선)
    &lt;ul&gt;
      &lt;li&gt;none(기본값), underline, line-through&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;배경background&quot;&gt;배경(background)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;background-color : 요소의 배경 색상
    &lt;ul&gt;
      &lt;li&gt;기본 값 : transparent&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;background-image : 요소의 배경 이미지 삽입
    &lt;ul&gt;
      &lt;li&gt;기본 값 : none&lt;/li&gt;
      &lt;li&gt;이미지 경로 : url(“경로”)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;background-repeat : 요소의 배경 이미지 반복
    &lt;ul&gt;
      &lt;li&gt;기본 값 : repeat(이미지를 수직, 수평 반복)&lt;/li&gt;
      &lt;li&gt;repeat-x : 이미지를 수평 반복&lt;/li&gt;
      &lt;li&gt;repeat-y : 이미지를 수직 반복&lt;/li&gt;
      &lt;li&gt;no-repeat : 반복 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;background-position : 요소의 배경 이미지 위치
    &lt;ul&gt;
      &lt;li&gt;기본 값 : 0% 0%&lt;/li&gt;
      &lt;li&gt;방향 : top, bottom, left, right, center
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;background-position : top right; =&amp;gt; 오른쪽 상단에 위치
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;단위 : px, em, rem 등 단위로 지정
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;background-position : 100px 30px; =&amp;gt; 축으로 부터 가로 100px, 세로 30px
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;background-size : 요소의 배경 이미지 크기
    &lt;ul&gt;
      &lt;li&gt;기본 값 : auto&lt;/li&gt;
      &lt;li&gt;단위 : px, em, rem 등 단위로 지정&lt;/li&gt;
      &lt;li&gt;cover : 비율을 유지, 요소의 더 넓은 너비에 맞춤&lt;/li&gt;
      &lt;li&gt;contain : 비율을 유지, 요소의 더 짧은 너비에 맞춤&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;background-attachment : 요소의 배경 이미지 스크롤 특성
    &lt;ul&gt;
      &lt;li&gt;기본 값 : scroll, 이미지가 요소를 따라서 같이 스크롤&lt;/li&gt;
      &lt;li&gt;fixed : 이미지가 뷰포트에 고정, 스크롤 X&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;배치position&quot;&gt;배치(position)&lt;/h4&gt;

&lt;p&gt;요소의 위치 지정 기준 (음수 가능)&lt;/p&gt;

&lt;p&gt;✔️ 요소의 쌓임 순서&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;요소에 position 속성의 값이 있는 경우 위에 쌓임.&lt;/li&gt;
  &lt;li&gt;1번 조건이 같은 경우, z-index 속성의 숫자 값이 높을 수록 위에 쌓임.&lt;/li&gt;
  &lt;li&gt;1번, 2번 조건가지 같은 경우, HTML의 다음 구조일 수록 위에 쌓임.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;기본 값 : static (기준 없음)&lt;/li&gt;
  &lt;li&gt;relative : 요소 자신을 기준&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;position: relative; =&amp;gt; 화면에는 아무런 변화가 없다.
top : 30px;
left: 20px;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;❗️ absolute, fixed가 지정된 요소는 display 속성이 bolck으로 변경 됨 ❗️&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;absolute : 위치 상 부모 요소를 기준&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 위치 상 부모 요소를 기준으로 하기 때문에 부모 요소에 relative 속성을 부여해줘야 한다.
position : absolute;
top : 30px;
bottom : 30px;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;fixed : 뷰포트(브라우저)를 기준&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;개별 속성&lt;br /&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;top, bottom, left, right&lt;/li&gt;
      &lt;li&gt;z-index
        &lt;ul&gt;
          &lt;li&gt;기본 값 : auto&lt;/li&gt;
          &lt;li&gt;숫자 : 숫자가 높을 수록 위에 쌓임&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;전환transition&quot;&gt;전환(transition)&lt;/h4&gt;

&lt;p&gt;요소의 전환(시작과 끝) 효과를 지정하는 단축 속성&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;trasition : 속성명 &lt;span style=&quot;color:red&quot;&gt;지속시간&lt;/span&gt; 타이밍함수 대기시간;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;transition-property(속성명) :전환 효과를 사용할 속성 이름을 지정
        &lt;ul&gt;
          &lt;li&gt;all(기본 값) : 모든 속성에 적용&lt;/li&gt;
          &lt;li&gt;속성이름 : 전환 효과를 사용할 속성 이름 명시&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;transition-duration(지속시간) : 전환 효과의 시간을 지정
        &lt;ul&gt;
          &lt;li&gt;0s(기본 값) : 전환 효과 없음&lt;/li&gt;
          &lt;li&gt;시간 : 지속시간(s)을 지정&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;transition-timing-funciton : 전환 효과의 타이밍(Easing) 함수를 지정
        &lt;ul&gt;
          &lt;li&gt;ease(기본 값) : 느리게 - 빠르게 - 느리게&lt;/li&gt;
          &lt;li&gt;linear : 일정하게&lt;/li&gt;
          &lt;li&gt;ease-in : 느리게 - 빠르게&lt;/li&gt;
          &lt;li&gt;ease-out : 빠르게 - 느리게&lt;/li&gt;
          &lt;li&gt;ease-in-out : 느리게 쁘라게 - 느리게&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;transition-delay : 전환 효과가 몇 초 뒤에 시작할지 대기시간을 지정
        &lt;ul&gt;
          &lt;li&gt;0s(기본 값) : 대기시간 없음&lt;/li&gt;
          &lt;li&gt;시간 : 대기시간(s)을 지정&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;변환transform&quot;&gt;변환(transform)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;2D 변환 함수&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;translate(x,y) : 이동(x축, y축)&lt;/li&gt;
      &lt;li&gt;translateX(x) : 이동(x축)&lt;/li&gt;
      &lt;li&gt;translateY(y) : 이동(y축)&lt;/li&gt;
      &lt;li&gt;scale(x,y) : 크기(x축, y축)&lt;/li&gt;
      &lt;li&gt;rotate(degree) : 회전(각도)&lt;/li&gt;
      &lt;li&gt;skewX(x) : 기울임(x축)&lt;/li&gt;
      &lt;li&gt;skewY(y) : 기울임(y축)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3D 변환 함수&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;rotateX(x) : 회전(x축)&lt;/li&gt;
      &lt;li&gt;rotateY(y) : 회전(y축)&lt;/li&gt;
      &lt;li&gt;perspective(n) : 원근법(거리)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><category term="frontend" /><category term="HTML" /><summary type="html">CSS 우선순위</summary></entry><entry><title type="html">React-TypeScript</title><link href="https://sungseokmin.github.io/frontend/react-typescript/react-typescript-copy/" rel="alternate" type="text/html" title="React-TypeScript" /><published>2021-02-20T00:00:00+09:00</published><updated>2021-02-20T00:00:00+09:00</updated><id>https://sungseokmin.github.io/frontend/react-typescript/react-typescript%20copy</id><content type="html" xml:base="https://sungseokmin.github.io/frontend/react-typescript/react-typescript-copy/">&lt;blockquote&gt;
  &lt;h2 id=&quot;react에서-typescript-사용하기--redux&quot;&gt;React에서 TypeScript 사용하기 + Redux&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;❗️ 시작하기 전에 ❗️&lt;br /&gt;
TypeScript를 사용하면서 어떤 건 .ts이고 어떤 건 .tsx인지 궁금했다.&lt;br /&gt;
Component를 작성 시 .tsx를 사용하고 그 외에는 .ts를 사용&lt;/p&gt;

&lt;h3 id=&quot;todolist&quot;&gt;TodoList&lt;/h3&gt;

&lt;h4 id=&quot;파일-구조&quot;&gt;파일 구조&lt;/h4&gt;

&lt;p&gt;&lt;img width=&quot;265&quot; alt=&quot;스크린샷 2021-02-20 오후 2 44 50&quot; src=&quot;https://user-images.githubusercontent.com/72539723/108585206-893ba280-738a-11eb-909b-9a32937333b6.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;redux-setting&quot;&gt;Redux Setting&lt;/h3&gt;

&lt;h4 id=&quot;indexts&quot;&gt;index.ts&lt;/h4&gt;

&lt;p&gt;✔️ 궁금해&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;export * from ‘path’ ?
    &lt;ul&gt;
      &lt;li&gt;from 뒤에 오는 path에서 export된 것들을 가져와서 내보내준다는 의미!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export {default} from './reducer';
export * from './actions';
export * from './types';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;actionsts&quot;&gt;actions.ts&lt;/h4&gt;

&lt;p&gt;✔️ 궁금해&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;typesafe-actions ?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;action, reducer를 보다 편한히 사용하기 위한 라이브러리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;타입을 초기화 할 때 as const를 넣는 이유 ?&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;action 함수를 생성할 때 생성될 함수의 타입을 명확히 하기 위해서 !&lt;/li&gt;
      &lt;li&gt;as const를 작성한 경우
        &lt;ul&gt;
          &lt;li&gt;&lt;img width=&quot;302&quot; alt=&quot;스크린샷 2021-02-20 오후 2 58 43&quot; src=&quot;https://user-images.githubusercontent.com/72539723/108585488-22b78400-738c-11eb-9fa2-5985f60e38d8.png&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;as const를 작성하지 않은 경우
        &lt;ul&gt;
          &lt;li&gt;&lt;img width=&quot;305&quot; alt=&quot;스크린샷 2021-02-20 오후 2 58 15&quot; src=&quot;https://user-images.githubusercontent.com/72539723/108585462-129fa480-738c-11eb-9079-01b6f4b8c9aa.png&quot; /&gt; &lt;br /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import { deprecated } from 'typesafe-actions';
const { createStandardAction } = deprecated;

export const ADD_TODO = 'todos/ADD_TODO' as const;
export const TOGGLE_TODO = 'todos/TOGGLE_TODO';
export const REMOVE_TODO = 'todos/REMOVE_TODO';

// 게시글 번호를 위해 변수 생성
let nextId = 1;

// 기존 방식의 action 함수 생성
export const addTodo = (text: string) =&amp;gt; ({
  type: ADD_TODO,
  payload: {
    id: nextId++,
    text,
  },
});

❗️ 조심 해야 하는 부분 ❗️
매개변수로 받아오는 값이랑 payload르 이용해 내보내주는 값이 다른 경우에는 createStandardAction을 사용하는 것이 아니라 createAction 메소드를 사용해야 한다.

// typesafe-actions 라이브러리를 이용한 action 함수 생성
export const toggleTodo = createStandardAction(TOGGLE_TODO)&amp;lt;number&amp;gt;();
export const removeTodo = createStandardAction(REMOVE_TODO)&amp;lt;number&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;typests&quot;&gt;types.ts&lt;/h4&gt;

&lt;p&gt;TypeScript를 사용하기 때문에 타입을 지정 해주기 위한 파일&lt;/p&gt;

&lt;p&gt;✔️ 궁금해&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ActionType ?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;기존의 방식대로 작성을 하면 aciont 함수를 구현한 수 만큼 ReturnType을 이용해 다 적어줘야 했지만 한 번에 하는 방법이 있다&lt;/li&gt;
      &lt;li&gt;ActionType을 사용한 경우 (둘 다 같은 결과가 나온다.)
        &lt;ul&gt;
          &lt;li&gt;&lt;img width=&quot;623&quot; alt=&quot;스크린샷 2021-02-20 오후 3 19 21&quot; src=&quot;https://user-images.githubusercontent.com/72539723/108585976-02d58f80-738f-11eb-94a7-1dd0f4fc9530.png&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ActionType을 사용하지 않은 경우
        &lt;ul&gt;
          &lt;li&gt;&lt;img width=&quot;630&quot; alt=&quot;스크린샷 2021-02-20 오후 3 18 41&quot; src=&quot;https://user-images.githubusercontent.com/72539723/108585966-edf8fc00-738e-11eb-8c5c-dd819b6fafb2.png&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Todo[] ?&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Todo라는 타입을 배열로 하겠다는 의미 !&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import {ActionType} from 'typesafe-actions;
import * as actions from './actions';

export type TodoAction = ActionType&amp;lt;typeof actions&amp;gt;;

export type Todo = {
  id: number;
  text: string;
  done: boolean;
};

export type TodoState = Todo[];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;reducerts&quot;&gt;reducer.ts&lt;/h4&gt;

&lt;p&gt;✔️ 궁금해&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;createReducer ?
    &lt;ul&gt;
      &lt;li&gt;보다 간편한 문법으로 reducer를 작성하기 위해 사용한 메소드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;☀️ 어떤 문법을 사용하는 자기 마음 ☀️&lt;/li&gt;
  &lt;li&gt;기존 redux reducer 방식
    &lt;ul&gt;
      &lt;li&gt;&lt;img width=&quot;623&quot; alt=&quot;스크린샷 2021-02-20 오후 3 41 14&quot; src=&quot;https://user-images.githubusercontent.com/72539723/108586459-13d3d000-7392-11eb-9185-5848c4247c0e.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import { createReducer } from 'typesafe-actions;
import { ADD_TODO, REMOVE_TODO, TOGGLE_TODO } from './actions';
import { TodoAction, TodoState } from './types';

// types에서 지정한 타입을 initalState의 타입으로 설정
const initialState: TodoState = [];

const todos = createReducer&amp;lt;TodoState, TodoAction&amp;gt;(initialState, {
  [ADD_TODO] : (state, action) =&amp;gt;
    state.concat({
      ...action.payload,
      done: false
    }),
  [TOGGLE_TODO]: (state, action) =&amp;gt;
    state.map((todo) =&amp;gt; (todo.id === action.payload ? { ...todo, done: !todo.done} : todo)),
  [REMOVE_TODO]: (state, action) =&amp;gt;
    state.filter((todo) =&amp;gt; todo.id !== action.payload),
})

export default todos;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;modules--indexjs&quot;&gt;modules &amp;gt; index.js&lt;/h4&gt;

&lt;p&gt;rootReducer 생성&lt;/p&gt;

&lt;p&gt;✔️ 궁금해&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;combineReducers ?
    &lt;ul&gt;
      &lt;li&gt;여러개의 reducer를 combine(결합)시키기 위해 사용되는 메소드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;왜 export를 두 번 하지 ?
    &lt;ul&gt;
      &lt;li&gt;combine한 rootReducer와 그 reducer의 Type을 내보낸다!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import { combineReducers } from 'redux';
import todos from './todos';

const rootReducer = combineReducers({
  todos,
})

export default rootReducer;
export RootState = ReturnType&amp;lt;typeof rootReducer&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;compoent-setting&quot;&gt;Compoent Setting&lt;/h2&gt;

&lt;h4 id=&quot;apptsx&quot;&gt;App.tsx&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import React from 'react';
import TodoApp from './containers/TodoApp';


function App() {
  return &amp;lt;TodoApp /&amp;gt;
}

export default App;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;indextsx&quot;&gt;index.tsx&lt;/h4&gt;

&lt;p&gt;열심히 Redux를 만들었으니 store를 생성 해야겠죠 !?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import { Provider } from 'react-redux';
import { createStore } from 'redux';
import rootReducer from './modlues';

const store = createStore(rootReducer);

ReactDOM.render(
  &amp;lt;Provider store={store}&amp;gt;
    &amp;lt;App /&amp;gt;
  &amp;lt;/Provider&amp;gt;,
  document.getElementById('root')
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;todoapptsx&quot;&gt;TodoApp.tsx&lt;/h4&gt;

&lt;p&gt;전체적인 메소드를 관리하면서 자식 Compoenent에 props로 메소드를 내려주는 역할&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import React from 'react';
import { useDispatch, useSelector } from 'react-redux';
import TodoInsert from '../components/TodoInsert';
import TodoList from '../components/TodoList';
import { Rootstate } from '../modlues';
import { addTodo, toggleTodo, removeTodo } from '../modlues/todos/actions';

function TodoApp() {
  // useSelector를 이용해 store에 있는 todos에 접근한다.
  const todos = useSelector((state: Rootstate) =&amp;gt; state.todos);
  const dispatch = useDispatch();

  const onInsert = (text: string) =&amp;gt; {
    dispatch(addTodo(text));
  }

  const onToggle = (id: number) =&amp;gt; {
    dispatch(toggleTodo(id));
  }

  const onRemove = (id: number) =&amp;gt; {
    dispatch(removeTodo(id));
  }

  return (
    &amp;lt;&amp;gt;
      &amp;lt;TodoInsert onInsert={onInsert}&amp;gt;
      &amp;lt;TodoList todos={todos} onToggle={onToggle} onRemove={onRemove}&amp;gt;
    &amp;lt;/&amp;gt;
  )
}

export default TodoApp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;todoinsert&quot;&gt;TodoInsert&lt;/h3&gt;

&lt;p&gt;할 일을 추가할 수 있도록 구현한 Component&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import React, { FormEvent, useState } from 'react';

// 부모 Component로부터 받는 props의 타입을 정해준다.
type todoInsertProps = {
  onInsert: (text: string) =&amp;gt; void;
}

function TodoInsert({ onInsert }: todoInserProps) {
  const [value, setValue] = useState('');

  const onChange = (e: React.ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; {
    setValue(e.target.value);
  }

  const onSubmit = (e: FormEvent) =&amp;gt; {
    e.preventDefault();
    onInsert(value);
    setValue('');
  }

  return (
    &amp;lt;form onSubmit={onSubmit}&amp;gt;
      &amp;lt;input value={value} onChange={onChange} placeholder=&quot;할 일을 입력하세요.&quot;&amp;gt;
      &amp;lt;button type=&quot;submit&quot;&amp;gt;등록하기&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  )
}

export default TodoInsert;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;todolisttsx&quot;&gt;TodoList.tsx&lt;/h4&gt;

&lt;p&gt;전체적인 게시판을 관리하는 Component&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import React from 'react';
import { Todo } from '../modules/todos';
import TodoItem from './TodoItem';

type TodoListProps = {
  todos: Todo[];
  onToggle: (id: number) =&amp;gt; void;
  onRemove: (id: number) =&amp;gt; void;
}

function TodoList({todos, onToggle, onRemove}: TodoListProps) {
  if(todos.length === 0) return &amp;lt;p&amp;gt;등록된 항목이 없습니다.&amp;lt;/p&amp;gt;
  return (
    &amp;lt;ul&amp;gt;
      {todos.map(todo) =&amp;gt; (&amp;lt;TodoItem todo={todo} onToggle={onToggle} onRemove={onRemove}&amp;gt;)}
    &amp;lt;/ul&amp;gt;
  )
}

export default TodoList;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;todoitemtsx&quot;&gt;TodoItem.tsx&lt;/h4&gt;

&lt;p&gt;할 일을 하나하나 관리하는 Component&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import React, { CSSProperties } from 'react';
import { Todo } from '../modlues/todos';

type TodoItemProps = {
  todo: Todo;
  onToggle: (id: number) =&amp;gt; void;
  onRemove: (id: number) =&amp;gt; void;

  function TodoItem({todo, onToggle, onRemove}: TodoItemProps) {
    const handleToggle = () =&amp;gt; onToggle(todo.id);
    const handleRemove = () =&amp;gt; onRemove(todo.id);

    const textStyle: CSSProperties = {
      textDecoration: todo.done ? 'line-through' : 'none',
    }

    const removeStyle: CSSProperties = {
      color: 'red',
      marginLeft: 8,
    }

    return (
      &amp;lt;li&amp;gt;
        &amp;lt;span onClick={handleToggle} style={textStyle}&amp;gt;
          {todo.text}
        &amp;lt;/span&amp;gt;
        &amp;lt;span onClick={handleRemove} style={removeStyle}&amp;gt;
          X
        &amp;lt;/span&amp;gt;
      &amp;lt;/li&amp;gt;
    )
  }
}

export default TodoItem;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;벨로퍼티님의 강의를 보고 나름 정리를 해보았다.&lt;br /&gt;
TypeScript 문법이 익숙하지 않았지만 계속 따라 쳐보고 생각하다 보니깐
어느 순간 손이 자동으로 움직이기 시작했고, 확실히 처음 공부를 한 것 보다
문법에 대한 이해도나 습득력이 늘었다고 해야하나? 다른 언어를 배우더라도 겁 내지 않고
할 수 있겠다 라는 생각을 가지고 다가갈 수 있을 것 같다.&lt;/p&gt;</content><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><category term="frontend" /><category term="react-typescript" /><summary type="html">React에서 TypeScript 사용하기 + Redux</summary></entry><entry><title type="html">TypeScript</title><link href="https://sungseokmin.github.io/frontend/typescript/typescript/" rel="alternate" type="text/html" title="TypeScript" /><published>2021-02-17T00:00:00+09:00</published><updated>2021-02-17T00:00:00+09:00</updated><id>https://sungseokmin.github.io/frontend/typescript/typescript</id><content type="html" xml:base="https://sungseokmin.github.io/frontend/typescript/typescript/">&lt;blockquote&gt;
  &lt;h2 id=&quot;typescript-&quot;&gt;TypeScript ?&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;자바스크립트에 타입을 적용시켜서 컴파일 환경에서 보다 쉽게 에러를 핸들링 할 수 있게 도와주는 프로그래밍 언어&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;never&quot;&gt;never&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;함수의 리턴 타입으로 사용(오류를 출력하거나 리턴 값을 내보내지 않음)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function error(message: string): never {
  throw new Error(error);
}

function fail() {
  return error('fail');
}

function infinitieLoop(): never {
  while(true){}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;void&quot;&gt;void&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;void : 함수의 리턴 타입으로 사용(어떤 타입도 가지지 않는 빈 상태를 의미)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function returnVoid(message: string) {
  console.log(message);
}

returnVoid('리턴이 없다');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;tuple&quot;&gt;Tuple&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Primitive type의 순서를 정확히 아는 경우 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let x: [string, number] = ['sung', 27]; // good!!
let y: [string, number] = ['sung', '스물일곫'] // error!!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;union-type&quot;&gt;Union Type&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;타입이 2개이상으로 될 것으로 기대할 때 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let x: string | number = '안녕하세요'; // good!!
또는
let x: string | number = 150; // good!!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;타입-추론type-inference&quot;&gt;타입 추론(Type Inference)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;TypeScript에서는 타입 표기가 없는 경우 자체에서 코드를 읽고 분석하여 타입을 유추해낼 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;526&quot; alt=&quot;스크린샷 2021-02-17 오전 11 17 55&quot; src=&quot;https://user-images.githubusercontent.com/72539723/108147326-f98bbf00-7111-11eb-877e-636402e29ca2.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;타입-명시&quot;&gt;타입 명시&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;변수를 선언할 때, 변수 값의 타입을 명시함으로써 변수 값의 데이터 타입을 지정하는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;614&quot; alt=&quot;스크린샷 2021-02-17 오전 11 36 40&quot; src=&quot;https://user-images.githubusercontent.com/72539723/108148564-6902ae00-7114-11eb-9481-a32cf645f849.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;타입-별칭-type-alias&quot;&gt;타입 별칭 (Type Alias)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;타입에 직접 이름을 부여하고 재사용이 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type User = {
  name: string;
  age: number;
}

const user1: User = {
  name: '성석민',
  age: 27,
}

const user2: User = {
  name: '홍길동',
  age: 30,
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;interface&quot;&gt;interface&lt;/h3&gt;

&lt;p&gt;타입으로 사용되는 interface&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;interface에 정의된 변수가 전부 return되어야 한다면 ?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;472&quot; alt=&quot;스크린샷 2021-02-17 오전 11 49 22&quot; src=&quot;https://user-images.githubusercontent.com/72539723/108149428-2e9a1080-7116-11eb-9360-ad352c61f9b2.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;interface에 정의는 했지만 return을 안 하고 싶다면 ?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;473&quot; alt=&quot;스크린샷 2021-02-17 오전 11 49 40&quot; src=&quot;https://user-images.githubusercontent.com/72539723/108149446-38bc0f00-7116-11eb-8d4f-9e06b388dde5.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;interface 상속&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Person {
  name: string;
  age?: number;
}

interface Developer {
  skills: string[];
}

const person extends Person = {
  name: '김코딩',
  age: 27,
}

const myInfo extends Developer{
  name: '성석민',
  skills: [ 'javascript', 'typescript' ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;enum--literal-type&quot;&gt;Enum &amp;amp; Literal Type&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Enum&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;518&quot; alt=&quot;스크린샷 2021-02-17 오후 12 40 08&quot; src=&quot;https://user-images.githubusercontent.com/72539723/108152846-46c15e00-711d-11eb-8d75-4cd528d95eb2.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Literal&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;522&quot; alt=&quot;스크린샷 2021-02-17 오후 12 40 40&quot; src=&quot;https://user-images.githubusercontent.com/72539723/108152897-58a30100-711d-11eb-9cc2-894e78b5843d.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;✔️ Literal Type이 가독성이 좋아 많이 사용한다고 한다!!&lt;/p&gt;

&lt;h3 id=&quot;type-aliases&quot;&gt;Type Aliases&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;interface와 동일하게 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Person = {
  name: string;
  age?: number;
}

type Developer = Person &amp;amp; {
  skills: string[];
}

const person: Person = {
  name: '김코딩',
  age: 27,
}

const myInfo: Developer = {
  name: '성석민',
  skills: [ 'javascript', 'typescript' ]
}

type People = Person[];

const people: People = [person, myInfo]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;접근제한자access-modifiers&quot;&gt;접근제한자(Access Modifiers)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;public : 어디서든 접근 가능, default&lt;/li&gt;
  &lt;li&gt;private : class 내부에서만 접근 가능&lt;/li&gt;
  &lt;li&gt;protected : class 내부, 상속받은 자식 class에서 접근 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;tsctypescript-compiler-사용&quot;&gt;tsc(typescript compiler) 사용&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;app.js 파일 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function info(name: string) {
  console.log(name);
}

name('성석민');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;터미널을 실행 시킨 후 다음과 같은 명령 실행&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// tsc ? typescript compiler
// 자동으로 app.js 파일을 생성해준다. typescript -&amp;gt; javascript
tsc app.ts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;app.ts 파일을 보면 Duplicate function implementation 오류가 발생&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;이것을 해결하기 위한 방법은 터미널을 실행 시킨 후 다음과 같은 명령 실행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tsc --init

-&amp;gt; tsconfig.json 파일이 생성된다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;app.ts에서 코드를 삭제 후 app.js파일에 가보면 코드가 그대로 남아있는 것을 볼 수 있다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;이것을 해결하기 위한 방법은 터미널을 실행 시킨 후 다음과 같은 명령 실행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// w = watch (감시한다!!)
tsc -w
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;</content><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><category term="frontend" /><category term="typescript" /><summary type="html">TypeScript ?</summary></entry><entry><title type="html">Redux</title><link href="https://sungseokmin.github.io/frontend/redux/Redux/" rel="alternate" type="text/html" title="Redux" /><published>2021-02-15T00:00:00+09:00</published><updated>2021-02-15T00:00:00+09:00</updated><id>https://sungseokmin.github.io/frontend/redux/Redux</id><content type="html" xml:base="https://sungseokmin.github.io/frontend/redux/Redux/">&lt;blockquote&gt;
  &lt;h2 id=&quot;redux&quot;&gt;Redux&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Flux개념을 바탕으로한 State관리 라이브러리&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/72539723/119288900-82237980-bc84-11eb-893e-eb86eb5506a2.png&quot; alt=&quot;redux&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;npm-설치&quot;&gt;Npm 설치&lt;/h4&gt;

&lt;p&gt;npm install redux&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;action&quot;&gt;Action&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;store(저장소)로 data를 보내는 방법
    &lt;ul&gt;
      &lt;li&gt;두 가지 형태의 액션 존재
        &lt;ul&gt;
          &lt;li&gt;{type: ‘타입’}&lt;/li&gt;
          &lt;li&gt;{type: ‘타입’, params: ‘데이터’}&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// src/redux/actions.js

const ADD_TODO = 'ADD_TODO';

export function addTodo(todo) {
  return {
    type: ADD_TODO,
    todo,
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;reducers&quot;&gt;Reducers&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;action을 통해 타입을 정의 했으면, 그 결과로 인해 상태를 어떻게 바꿀 것인지 정의하는 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// src/redux/reducers.js

import { ADD_TODO } from './actions.js';

// 초기 state
// 빈 배열에 할일 목록을 하나씩 저장하려한다.
const initialState = [];

function todoApp(previousState = initialState, action) {
  switch (action.type) {
    case ADD_TODO:
      return [...previousState, action.todo];

    default:
      return previousState;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;store&quot;&gt;Store&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;store : state를 저장하는 객체&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// src/redux/store.js

import { createStore } from 'redux';
import { todoApp } from './reducers';

const store = createStore(todoApp);

export default store;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// index.js

import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { addTodo } from './redux/actions';
import store from './redux/store';

// ↓ 사진 첨부
console.log(store);

// store의 state 가져오기
console.log(store.getState()) =&amp;gt; 결과값 : [];

// store의 state 변경
store.dispatch(addTodo('coding'));
store.dispatch(addTodo('read book'));

console.log(store.getState()); =&amp;gt; 결과값 : ['coding', 'read book'];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/72539723/119291772-f876aa80-bc89-11eb-8d7b-ac95ade93be3.png&quot; alt=&quot;스크린샷 2021-05-24 오후 12 16 52&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;combinereducers&quot;&gt;CombineReducers&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;현재 예제에서 reducer 함수는 하나로 정의되어 있지만 reducer 함수가 많아 질 수록 관리하기가 불편하다.
그래서 여러개의 reducer 함수를 묶어주는 역할이 CombineReducers 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;addTodoReducer와 removeTodoReudcer가 있다고 가정한다면 아래와 같이 reducer를 묶을 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import {combineReducers} from 'redux';

import addTodoReducer from './addTodoReducer';
import removeTodoReudcer from './removeTodoReudcer';

const rootReducer = combineReducers({
  addTodoReducer,
  removeTodoReducer
})

export default rootReducer;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;redux를-react로-연결&quot;&gt;Redux를 React로 연결&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;‘react-redux’ 모듈에 있는 useSelector와 useDispatch를 이용해 store에 있는 객체를 가져오고 변경할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import { useDispatch, useSelector } from 'react-redux';
import { addTodo, removeTodo } from './actions';

const state = useSelector(state =&amp;gt; state.addTodoReducer);

const dispatch = useDispatch();

dispatch(addTodo);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><category term="frontend" /><category term="redux" /><summary type="html">Redux</summary></entry><entry><title type="html">2 weeks project_시연영상 - ShapeOfVoice</title><link href="https://sungseokmin.github.io/project/2%20weeks%20project/Project-2/" rel="alternate" type="text/html" title="2 weeks project_시연영상 - ShapeOfVoice" /><published>2021-02-15T00:00:00+09:00</published><updated>2021-02-15T00:00:00+09:00</updated><id>https://sungseokmin.github.io/project/2%20weeks%20project/Project-2</id><content type="html" xml:base="https://sungseokmin.github.io/project/2%20weeks%20project/Project-2/">&lt;blockquote&gt;
  &lt;p&gt;Login&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/72539723/107925933-6c812280-6fb8-11eb-80bf-9fee727c6636.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;SignUp&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/72539723/107925939-6db24f80-6fb8-11eb-9624-8406f4be996d.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TempLogin&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/72539723/107925945-6e4ae600-6fb8-11eb-9b30-0f5101efe70d.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Capture &amp;amp; Clear&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/72539723/107925949-730f9a00-6fb8-11eb-98e3-623c1377db11.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;AddBoard&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/72539723/107925953-7440c700-6fb8-11eb-8699-a48cac405337.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;BoardDetail&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/72539723/107925956-760a8a80-6fb8-11eb-8768-12c43147a38a.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;MyPage&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/72539723/107925961-77d44e00-6fb8-11eb-8bb6-f019a9943fa2.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Logout&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/72539723/107925967-799e1180-6fb8-11eb-8056-27ad72c88182.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;</content><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><category term="project" /><category term="2 weeks project" /><summary type="html">Login</summary></entry><entry><title type="html">FlexBox</title><link href="https://sungseokmin.github.io/frontend/flexbox/Flex/" rel="alternate" type="text/html" title="FlexBox" /><published>2021-02-03T00:00:00+09:00</published><updated>2021-02-03T00:00:00+09:00</updated><id>https://sungseokmin.github.io/frontend/flexbox/Flex</id><content type="html" xml:base="https://sungseokmin.github.io/frontend/flexbox/Flex/">&lt;blockquote&gt;
  &lt;h3 id=&quot;flexbox-부모-속성&quot;&gt;FlexBox (부모 속성)&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Flex Container&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;flex-flow&lt;/li&gt;
      &lt;li&gt;flex-direction : 주 축(Main-Axis)을 설정
        &lt;ul&gt;
          &lt;li&gt;row(기본 값) : 행 축(좌 =&amp;gt; 우)&lt;/li&gt;
          &lt;li&gt;row-reverse : 행 축(우 =&amp;gt; 좌)&lt;/li&gt;
          &lt;li&gt;column : 열 축(위 =&amp;gt; 아래)&lt;/li&gt;
          &lt;li&gt;column-reverse : 열 축(아래 =&amp;gt; 위)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;flex-wrap : Flex Items 묶음(줄 바꿈) 여부
        &lt;ul&gt;
          &lt;li&gt;nowrap(기본 값) : 묶음(줄 바꿈) 없음&lt;/li&gt;
          &lt;li&gt;wrap : 여러 줄로 묶음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;justify-content : 주 축의 정렬 방법
        &lt;ul&gt;
          &lt;li&gt;flex-start(기본 값) : Flex Items를 시작점으로 정렬&lt;/li&gt;
          &lt;li&gt;flex-end : Flex Items를 끝점으로 정렬&lt;/li&gt;
          &lt;li&gt;center : Flex Items를 가운데 정렬&lt;/li&gt;
          &lt;li&gt;space-between : 각 Flex Item 사이를 균등하게 정렬&lt;/li&gt;
          &lt;li&gt;space-around : 각 Flex Item의 외부 여백을 균등하게 정렬&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;align-content : 교차 축의 여러 줄 정렬 방법 &lt;br /&gt;❗️ 여러 줄 주의 ! wrap을 통해 줄 바꿈이 일어나야 한다.
        &lt;ul&gt;
          &lt;li&gt;stretch(기본 값) : Flex Items를 시작점으로 정렬&lt;/li&gt;
          &lt;li&gt;flex-start : Flex Items를 시작점으로 정렬&lt;/li&gt;
          &lt;li&gt;flex-end : Flex Items를 끝점으로 정렬&lt;/li&gt;
          &lt;li&gt;center : Flex Items를 가운데 정렬&lt;/li&gt;
          &lt;li&gt;space-between : 각 Flex Item 사이를 균등하게 정렬&lt;/li&gt;
          &lt;li&gt;space-around : 각 Flex Item의 외부 여백을 균등하게 정렬&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;align-items : 교차 축의 한 줄 정렬 방법
        &lt;ul&gt;
          &lt;li&gt;stretch(기본 값) : Flex Items를 교차 축으로 늘림&lt;/li&gt;
          &lt;li&gt;flex-start : Flex Items를 각 줄의 시작점으로 정렬&lt;/li&gt;
          &lt;li&gt;flex-end : Flex Items를 각 줄의 끝점으로 정렬&lt;/li&gt;
          &lt;li&gt;center : Flex Items를 각 줄의 가운데 정렬&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;가로로-정렬된-모습을-볼-수-있다&quot;&gt;가로로 정렬된 모습을 볼 수 있다.&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/flexbox.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;display: flex;
flex-direction: row; // default값이기 때문에 적어주지 않아도 된다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;세로로-정렬된-모습을-볼-수-있다&quot;&gt;세로로 정렬된 모습을 볼 수 있다.&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/column.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;display: flex;
flex-direction: column;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;가로-축을-기준으로-가운데로-정렬된-모습을-볼-수-있다&quot;&gt;가로 축을 기준으로 가운데로 정렬된 모습을 볼 수 있다.&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/justify-content_center.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;display: flex;
flex-direction: row; // default값이기 때문에 적어주지 않아도 된다.
justify-content: center
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;가로-축을-기준으로-양-옆-공백-없는-사이에-간격을-둔-모습을-볼-수-있다&quot;&gt;가로 축을 기준으로 양 옆 공백 없는, 사이에 간격을 둔 모습을 볼 수 있다.&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/justify-content_between.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;display: flex;
flex-direction: row; // default값이기 때문에 적어주지 않아도 된다.
justify-content: space-between
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;가로-축을-기준으로-양-옆-공백이-있는-사이에-간격을-둔-모습을-볼-수-있다&quot;&gt;가로 축을 기준으로 양 옆 공백이 있는, 사이에 간격을 둔 모습을 볼 수 있다.&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/justify-content_around.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;display: flex;
flex-direction: row; // default값이기 때문에 적어주지 않아도 된다.
justify-content: space-around
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;세로-축을-기준으로-가운데-정렬된-모습을-볼-수-있다&quot;&gt;세로 축을 기준으로 가운데 정렬된 모습을 볼 수 있다.&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/center.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;display: flex;
flex-direction: column;
align-items: center;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;가로축을-기준으로-중앙으로-정렬된-모습을-볼-수-있다&quot;&gt;가로축을 기준으로 중앙으로 정렬된 모습을 볼 수 있다.&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/align-item.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;display: flex;
flex-direction: column
justify-content: center;
align-items: center;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;세로축을-기준으로-중앙으로-정렬된-모습을-볼-수-있다&quot;&gt;세로축을 기준으로 중앙으로 정렬된 모습을 볼 수 있다.&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/middle.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;display: flex;
flex-direction: row;
justify-content: center;
align-items: center;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;flexbox-자식-속성&quot;&gt;FlexBox (자식 속성)&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Flex Items
    &lt;ul&gt;
      &lt;li&gt;order : Flex Item의 순서
        &lt;ul&gt;
          &lt;li&gt;0(기본 값) : 순서 없음&lt;/li&gt;
          &lt;li&gt;숫자 : 숫자가 작을 수록 먼저&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;flex&lt;/li&gt;
      &lt;li&gt;flex-grow : Flex Item의 증가 너비 비율
        &lt;ul&gt;
          &lt;li&gt;0(기본 값) : 증가 비율 없음&lt;/li&gt;
          &lt;li&gt;숫자 : 증가 비율&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;flex-shrink : Flex Item의 감소 너비 비율
        &lt;ul&gt;
          &lt;li&gt;1(기본 값) : Flex Container 너비에 따라 감소 비율 적용&lt;/li&gt;
          &lt;li&gt;숫자 : 감소 비율&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;flex-basis : Flex Item의 공간 배분 전 기본 너비
        &lt;ul&gt;
          &lt;li&gt;auto(기본 값) : 요소의 Content 너비&lt;/li&gt;
          &lt;li&gt;단위 : px, em, rem 등 단위로 지정&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;align-self&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;flex-basis&quot;&gt;flex-basis&lt;/h4&gt;

&lt;p&gt;기본 너비 설정, 기본 값: auto&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;flex-grow&quot;&gt;flex-grow&lt;/h4&gt;

&lt;p&gt;item의 증가 너비 비율 설정 &amp;amp;&amp;amp; 콘텐츠가 없는 여백의 공간을 비율적으로 나눠 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/grow.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.container {
height: 100vh;
background-color: gray;
display: flex;
flex-direction: row;
align-items: flex-start;
}
.item1 {
flex-grow: 1;
background-color: pink;
}
.item2 {
flex-grow: 2;
background-color: green;
}
.item3 {
flex-grow: 1;
background-color: yellow;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;flex-shrink&quot;&gt;flex-shrink&lt;/h4&gt;

&lt;p&gt;item의 감소 너비 비율을 설정&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;창 너비를 줄였을 때 1:2:1 비율로 줄어든다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/shrink.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.container {
height: 100vh;
background-color: gray;
display: flex;
flex-direction: row;
align-items: flex-start;
}
.item1 {
flex-shrink: 1;
background-color: pink;
}
.item2 {
flex-shrink: 2;
background-color: green;
}
.item3 {
flex-shrink: 1;
background-color: yellow;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;align-self&quot;&gt;align-self&lt;/h4&gt;

&lt;p&gt;각각의 요소를 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/align-self.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.container {
height: 100vh;
background-color: gray;
display: flex;
flex-direction: row;
align-items: flex-start;
}
.item1 {
flex: 1;
align-self: flex-start;
background-color: pink;
}
.item2 {
flex: 1;
align-self: center;
background-color: green;
}
.item3 {
flex: 1;
align-self: flex-end;
background-color: yellow;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><category term="frontend" /><category term="flexbox" /><summary type="html">FlexBox (부모 속성)</summary></entry></feed>