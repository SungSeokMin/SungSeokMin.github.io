I"Q<h2 id="robot-path">Robot Path</h2>

<h3 id="문제설명">문제설명</h3>

<blockquote>
  <p>2차원 배열(room), 현재 지점(src), 도착 지점(dst)
세로(M), 가로(N) 2차원 배열(room)
1은 장애물, 0은 이동 가능한 통로를 의미한다.
로봇은 지도 위를 일분에 한 칸씩 상하좌우로 이동 할 수 있다.
로봇의 위치와 목표 지점이 함께 주어질 경우
로봇이 목표 지점까지 도달하는 데 걸리는 최소 시간을 리턴</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let room = [
  [0, 0, 0, 0, 0, 0],
  [0, 1, 1, 0, 1, 0],
  [0, 1, 0, 0, 0, 0],
  [0, 0, 1, 1, 1, 0],
  [1, 0, 0, 0, 0, 0],
];
let src = [4, 2];
let dst = [2, 2];
let output = robotPath(room, src, dst);
console.log(output); // --&gt; 8
</code></pre></div></div>

<hr />

<h2 id="의사코드">의사코드</h2>

<ol>
  <li>recursion 함수 생성 … (세로의 길이, 가로의 길이, 현재 지점, 최소시간=1)</li>
  <li>배열의 범위가 벗어난 경우 return</li>
  <li>room의 [row, col]이 0인 경우 와 최소시간 보다 큰 경우
3.1 room의 [row, col]을 최소시간(step)으로 초기화 한다.</li>
  <li>그것이 아니면 return
4.1 그 이유 ? 장애물이 이미 1이거나, 최소 시간으로 통과 가능한 경우니깐 !</li>
  <li>상하좌우로 재귀한다.</li>
  <li>완전탐색이 끝나면 도착지점의 row, col을 구조분해 하고</li>
  <li>room의 row, col 자리의 값 = 최소시간에서 1을 빼준다.
7.1 그 이유? 방문하지 않기 위해 로봇의 위치를 1로 초기화 하면
7.2 바로 옆 통로는 1이 증가한다.</li>
</ol>

<h2 id="작성한-코드">작성한 코드</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function solution(arr) {
    let answer = [];
    let first = arr[0];
    answer.push(first);

    for(let i= 1; i&lt; arr.length; i++) {
        if(first !== arr[i]) {
            first = arr[i];
            answer.push(first)
        }
    }
    return answer;
}
</code></pre></div></div>

<hr />

<p>작성한 코드로 통과하였지만, 다른사람이 푼 풀이가 정말 간단한 것을 찾았다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function solution(arr) {
    return arr.filter((x, index) =&gt; x !== arr[index + 1])
}
</code></pre></div></div>

<p>filter 메서드를 사용하였고, 인덱스를 추가하며 같지 않다면 리턴해주는 방식으로 구현되어있는데 정말 간단하고 대단한 것 같다.</p>

<hr />

<p>알고리즘 또한 부족한 부분이기 때문에, 항상 하루에 1~2개 씩은 꼭 풀고 있는 것 같다.
앞으로도 매일 알고리즘 공부를 틈틈히 하며 블로깅하도록 하겠다.</p>
:ET