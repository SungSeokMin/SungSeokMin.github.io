<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://sungseokmin.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sungseokmin.github.io/" rel="alternate" type="text/html" /><updated>2021-01-30T15:10:13+09:00</updated><id>https://sungseokmin.github.io/feed.xml</id><title type="html">Happy Developer, 성석민</title><subtitle>Happy Blog</subtitle><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><entry><title type="html">LSCS-연속된 부분 배열의 합의 최대값</title><link href="https://sungseokmin.github.io/algorithm/LSCS/" rel="alternate" type="text/html" title="LSCS-연속된 부분 배열의 합의 최대값" /><published>2021-01-30T00:00:00+09:00</published><updated>2021-01-30T00:00:00+09:00</updated><id>https://sungseokmin.github.io/algorithm/LSCS</id><content type="html" xml:base="https://sungseokmin.github.io/algorithm/LSCS/">&lt;h2 id=&quot;lscs&quot;&gt;LSCS&lt;/h2&gt;

&lt;h3 id=&quot;문제설명&quot;&gt;문제설명&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;정수를 요소로 갖는 배열 &lt;br /&gt;
주어진 배열의 연속된 부분 배열의 합을 구한다.&lt;br /&gt;
이 중 가장 큰 값을 리턴해야 한다.&lt;br /&gt;
배열의 모든 요소가 음수인 경우도 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let output = LSCS([1, 2, 3]);
console.log(output); // --&amp;gt; 6

output = LSCS([1, 2, 3, -4]);
console.log(output); // --&amp;gt; 6

LSCS([1, 2, 3, -4, 5]);
console.log(output); // --&amp;gt; 7

LSCS([10, -11, 11]);
console.log(output); // --&amp;gt; 11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;수도코드&quot;&gt;수도코드&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;연속된 배열의 합을 저장할 변수 생성&lt;/li&gt;
  &lt;li&gt;연속된 부분 배열의 합을 저장할 변수 생성&lt;br /&gt;
2.1 Number.MIN_SAFE_INTEGER = -900719925474099&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;배열의 길이만큼 반복 … for loop&lt;/li&gt;
  &lt;li&gt;각각의 요소를 1번 변수에 저장 +=&lt;/li&gt;
  &lt;li&gt;만약 1번 변수의 합이 최대값 보다 클 경우 2번 변수에 저장&lt;/li&gt;
  &lt;li&gt;연속된 부분 배열의 합이 0보다 작을 경우 0으로 초기화를 해도 된다.&lt;/li&gt;
  &lt;li&gt;2번 변수를 return 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;풀이-코드&quot;&gt;풀이 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const LSCS = function(arr) {
  let result = 0;
  let max = Number.MIN_SAFE_INTEGER;

  for(let i = 0; i &amp;lt; arr.length; i++) {
    // 부분 합을 저장
    result += arr[i]

    // 최대값을 저장
    if(result &amp;gt; max) {
      max = result;
    }

    // 부분 합이 음수 인 경우 0으로 초기화
    if(result &amp;lt; 0) {
      result = 0;
    }
  }
  return max;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;간단한 문제라고 생각했지만 부분 합의 최대값 이라는 부분에서 어떻게 풀어가야할 지 생각이 많았다.&lt;/p&gt;</content><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><category term="algorithm" /><summary type="html">LSCS</summary></entry><entry><title type="html">최소시간으로 길찾기-완전탐색</title><link href="https://sungseokmin.github.io/algorithm/robotPath/" rel="alternate" type="text/html" title="최소시간으로 길찾기-완전탐색" /><published>2021-01-30T00:00:00+09:00</published><updated>2021-01-30T00:00:00+09:00</updated><id>https://sungseokmin.github.io/algorithm/robotPath</id><content type="html" xml:base="https://sungseokmin.github.io/algorithm/robotPath/">&lt;h2 id=&quot;robot-path&quot;&gt;Robot Path&lt;/h2&gt;

&lt;h3 id=&quot;문제설명&quot;&gt;문제설명&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;2차원 배열(room), 현재 지점(src), 도착 지점(dst) &lt;br /&gt;
1은 장애물, 0은 이동 가능한 통로를 의미한다. &lt;br /&gt;
로봇은 지도 위를 일분에 한 칸씩 상하좌우로 이동 할 수 있다. &lt;br /&gt;
로봇의 위치와 목표 지점이 함께 주어질 경우
로봇이 목표 지점까지 도달하는 데 걸리는 최소 시간을 리턴&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let room = [
  [0, 0, 0, 0, 0, 0],
  [0, 1, 1, 0, 1, 0],
  [0, 1, 0, 0, 0, 0],
  [0, 0, 1, 1, 1, 0],
  [1, 0, 0, 0, 0, 0],
];
let src = [4, 2];
let dst = [2, 2];
let output = robotPath(room, src, dst);
console.log(output); // --&amp;gt; 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;수도코드&quot;&gt;수도코드&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;recursion 함수 생성 … (세로의 길이, 가로의 길이, 현재 지점, 최소시간=1)&lt;/li&gt;
  &lt;li&gt;배열의 범위가 벗어난 경우 return&lt;/li&gt;
  &lt;li&gt;room의 [row, col]이 0인 경우 와 최소시간 보다 큰 경우 &lt;br /&gt;
3.1 room의 [row, col]을 최소시간(step)으로 초기화 한다.&lt;/li&gt;
  &lt;li&gt;그것이 아니면 return &lt;br /&gt;
4.1 그 이유 ? 장애물이 이미 1이거나, 최소 시간으로 통과 가능한 경우니깐 !&lt;/li&gt;
  &lt;li&gt;상하좌우로 재귀한다.&lt;/li&gt;
  &lt;li&gt;완전탐색이 끝나면 도착지점의 row, col을 구조분해 하고&lt;/li&gt;
  &lt;li&gt;room의 row, col 자리의 값 = 최소시간에서 1을 빼준다. &lt;br /&gt;
7.1 그 이유? 방문하지 않기 위해 로봇의 위치를 1로 초기화 하면&lt;br /&gt;
7.2 바로 옆 통로는 1이 증가한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;풀이-코드&quot;&gt;풀이 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const robotPath = function (room, src, dst) {
  const recursion = (M, N, path, step) =&amp;gt; {
    // 현재 점을 저장
    const [row, col] = path;

    // 배열의 범위를 벗어난 경우
    if(row &amp;lt; 0 || row &amp;gt;= M || col &amp;lt; 0 || col &amp;gt;= N) {
      return;
    }

    // 이동할 수 있는 경우
    if(room[row][col] === 0 || room[row][col] &amp;gt; step) {
      room[row][col] = step;
    } else {
      return;
    }

    // 상
    recursion(M, N, [row+1, col], step + 1);
    // 하
    recursion(M, N, [row-1, col], step + 1);
    // 좌
    recursion(M, N, [row, col-1], step + 1);
    // 우
    recursion(M, N, [row, col+1], step + 1);
  }
  // 세로, 가로, 현재지점, 최소시간
  recursion(room.length, room[0].length, src, 1);

  const [row, col] = dst;
  return room[row][col] -1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;문제파악과 해결하는 부분에서 시간이 엄청 오래걸렸다.
DFS, BFS에 대한 개념을 더 익히는 것이 필요한 것 같다.&lt;/p&gt;</content><author><name>SungSeokMin</name><email>jkl154527@gmail.com</email></author><category term="algorithm" /><summary type="html">Robot Path</summary></entry></feed>